## 基本常识

1. **自我介绍**

   您好，我叫*某某某。我目前正在某某大学攻读计算机技术硕士学位。在校期间，获得过某某奖项。并对前端开发产生了浓厚的兴趣，我学习了各类前端技术，并在课余时间积极参加了各种项目和比赛，以提升自己的技能水平。

   作为一个前端实习生，我有以下的技能和经验：

   - 熟练掌握 HTML 和 CSS 布局，能够快速构建响应式网站和应用程序界面
   - 熟悉 JavaScript 语法和基础知识，能够使用原生 JavaScript 开发交互性较强的动态页面
   - 掌握 Vue框架，熟悉组件生命周期、状态管理，能够开发复杂的单页应用程序
   - 熟悉版本控制工具 Git，能够使用 GitHub 进行团队协作和代码托管
   - 具备良好的沟通能力和团队合作精神，能够融入团队并与其他成员紧密合作，共同完成项目

   我非常热爱前端开发工作，并希望能够在您公司进行实习，学习和实践更多的技术，并为公司做出自己的贡献。谢谢！

2. **为什么学前端**

   1. 兴趣所在：前端开发是一个创造性的过程，它可以将设计师的想象力变成真正的网站或应用程序。我一直对良好的用户界面和用户体验产生浓厚的兴趣，这也是我选择学习并入行前端开发的主要原因。
   2. 前景看好：随着互联网的快速发展和普及，前端开发已经成为了市场上最具有竞争力的职业之一。现在许多公司都需要招聘优秀的前端工程师来开发自己的网站和应用程序。因此，我认为前端开发是一个非常有前途和有潜力的领域。
   3. 技术挑战：前端开发涉及到许多不同的技术和工具，如HTML、CSS、JavaScript、UI框架等。对于我这样喜欢学习新知识和探索新技术的人来说，前端开发提供了很好的机会来学习和实践这些技术，并且不断地挑战自己，提升自己的技能水平。
   4. 可以与他人合作：前端开发不仅是独立完成项目的工作，同时也需要与其他团队成员密切合作。前端开发人员需要了解设计师的要求和后端工程师的需求，以确保顺利地完成整个项目。这种协作和沟通的过程对我来说也是一个很好的学习机会，并且可以帮助我成为更好的团队成员。

   总之，选择学习前端开发是因为它与我的兴趣、职业前景、技术挑战和合作机会等方面都非常相符，我相信这是我未来职业生涯的最佳选择。

3. **常见的不稳定排序算法**

   在排序算法中，稳定性是指如果在待排序的数组中存在两个相等的元素，在排序后，它们**在数组中的相对位置是否发生变化**。如果相等元素的相对位置没有发生变化，那么这个排序算法就是稳定的；反之，则是不稳定的。

   1. 快速排序：快速排序是一种分治算法，通过划分将待排序数组划分为左右两个子数组，然后递归地对这两个子数组进行排序，最终得到有序数组。但是由于其涉及到元素的交换操作，因此它是不稳定的。
   2. 堆排序：堆排序是利用堆这种数据结构来实现排序的算法。堆分为大根堆和小根堆，大根堆要求每个节点的值都不大于其父节点的值，而小根堆要求每个节点的值都不小于其父节点的值。在堆排序中，我们首先将待排序数组构造成一个堆，然后将堆顶元素与堆底元素交换，并重新调整堆，最终得到有序数组。由于堆排序中涉及到元素的交换操作，因此它也是不稳定的。
   3. 希尔排序：希尔排序是一种改进版的插入排序算法，它通过在原始数据上进行多次排序，每次排序时将数据分成若干个小组，在每个小组内部进行插入排序。希尔排序的不稳定性来源于其间隔序列的选取方式。
   4. 直接选择排序法。基本思想是：第一趟从n个元素的数据序列中选出关键字最小（或最大）的元素并放到最前（或最后）位置，下一趟再从n-1个元素中选出最小（或最大）的元素并放到次前（后）位置，以此类推，经过n-1趟完成排序。涉及到元素的交换操作，因此它也是不稳定的。

   需要注意的是，并不是所有的排序算法都是不稳定的。例如，冒泡排序、插入排序和归并排序等算法都是稳定的排序算法。

4. **前端和其它方向的差异**

   前端和其他方向的差异主要体现在以下几个方面：

   1. 技术栈不同：前端开发侧重于 Web 前端技术，主要包括 HTML、CSS 和 JavaScript 等。而其他方向的开发可能会涉及到不同的编程语言和框架，如 Java、Python、Ruby、PHP、C# 等。
   2. 面向对象的程度不同：与 Java 或 Python 这样强调面向对象编程的语言相比，前端开发对面向对象编程的要求较低。虽然 JavaScript 也是一种支持面向对象编程的语言，但前端开发者通常更关注 DOM 操作和事件处理等技术。
   3. 设计和用户体验的角色不同：在前端开发中，设计和用户体验必须考虑得非常全面，因为网站或应用程序的界面直接影响着用户体验。而其他方向的开发更多地关注后端逻辑和数据交互等技术，设计和用户体验往往由专门的 UI 设计师或 UX 设计师来负责。
   4. 发布和部署的方式不同：前端开发需要了解 Web 应用程序的发布和部署，以确保将 Web 页面正确地呈现给用户。而其他方向的开发可能会涉及到不同的环境和部署方式，如云计算、服务器架构等。

   总体来说，虽然不同的开发方向有着各自独特的特点和技术栈，但所有这些领域都需要优秀的编码技能、团队合作精神以及对行业和技术发展趋势的敏锐洞察力。

5. **前端重要的知识有哪些方面**

   前端开发是一个涉及多个领域的综合性工作，其中包含了许多重要的知识点，以下是前端开发中重要的知识方面：

   1. HTML、CSS 和 JavaScript：这三个基础技术是前端开发的核心，掌握它们是非常必要的。
   2. 响应式 Web 设计：响应式设计可以使网站在不同的设备上自适应调整布局和显示效果。对于现代 Web 开发而言，响应式 Web 设计是一项非常重要的技能。
   3. UI 库和框架：如 Bootstrap、Material Design Lite、Foundation 等。使用这些库和框架可以更快地创建页面和应用，并且确保它们具有良好的用户体验和可靠性。
   4. 前端性能优化：前端性能优化包括缩小文件大小、减少 HTTP 请求次数、优化图片、压缩代码等等。理解并掌握这些技术可以使前端性能得到大幅度提升。
   5. 模块化开发：模块化开发是一种组织代码的方式，可以提高代码的复用性、可维护性和可扩展性。常见的模块化开发方案有 CommonJS、AMD 和 ES6 的模块系统等。
   6. 前端安全：了解 Web 安全问题、防范 XSS、CSRF 和 SQL 注入等安全攻击是前端开发必须掌握的知识点。
   7. 浏览器工作原理：了解浏览器工作原理可以帮助我们更好地理解 Web 开发，包括 DOM 树、CSS 渲染树、事件循环等。
   8. 前端工具链：如 Git、Webpack、Babel、LESS、SASS 等。这些工具可以大幅度提高前端开发效率和代码质量。
   9. 单元测试和集成测试：单元测试和集成测试是保证代码质量和应用程序稳定性的重要手段。

   总之，以上这些知识点都是前端开发中非常重要的方面，同时也需要不断学习和更新自己的技能。

6. 

## HTML与浏览器

1. **为什么 `setTimeout `不阻塞后⾯程序的运⾏？**

   因为 `setTimeout `不是由` js` 引擎线程完成的，是由定时器触发线程完成的，所以它们可以同时进⾏，那么定时器触发线程在这定时任务完成之后会通知事件触发线程往任务队列⾥添加事件。同理，也有异步` HTTP` 请求线程。

2. **常见的异步场景？**

   1. 定时器
   2. 网络请求
   3. 事件绑定
   4. Promise

3. **Event Loop 事件循环**

   记住script本身是宏任务，在这个过程中可能会创建微任务。

   先执行宏任务，再执行产生的所有微任务。（微任务在宏任务之间执行）

   - **常见的宏任务：**`script`整体代码、`setTimeout` 和 `setInterval`（`setImmediate`：`node` 的⽅法）、`requestAnimationFrame`、`I/O`、`UI rendering`

   - **常见的微任务：**`process.nextTick (Node环境中)`、`Promise callback`(例如 `promise.then`)、`MutationObserver`

   举例：主程序和 `setTimeout `都是宏任务，`promise `是微任务，第⼀个宏任务（主程序）执⾏完，执⾏全部的微任务（`promise`），再执⾏下⼀个宏任务
   （`setTimeout`）。

   还需要注意：await是等待，需要把**当前队列中的所有微任务执⾏完**，再执⾏await下面的内容。而await下⾯的内容执⾏完，才⼜执⾏宏任务。

   简述Event Loop 事件循环：Event Loop 事件循环是指浏览器或Node的一种解决JavaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。JavaScript是单线程的，即一次只能执行一个任务，而Event Loop就是用来协调任务执行的机制。当我们执行一个异步操作时，会将其放到Web API中，等合适的时候放入任务队列。当事件循环开始时，会先执行当前调用栈中的所有同步任务。在任务执行期间，如果产生了宏任务，会添加到宏任务队列。如果产生了微任务，那么这些微任务会被添加到微任务队列中，并在当前宏任务执行完毕后立即执行。如果在微任务执行期间产生了新的微任务，则这些新的微任务也会被添加到微任务队列中。只有当微任务队列为空时，才会去执行下一个宏任务。这个过程会一直持续下去，直到所有的任务都被处理完毕。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

   [JavaScript之彻底理解EventLoop - 掘金 (juejin.cn)](https://juejin.cn/post/7020328988715270157)

   [JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2014/10/event-loop.html)

4. **node.js 事件循环**

   ```
      ┌───────────────────────────┐
   ┌─>│           timers          │       # 执⾏ setTimeout 和 setInterval 的回调
   │  └─────────────┬─────────────┘		
   │  ┌─────────────┴─────────────┐
   │  │     pending callbacks     │		# 执行推迟到下一个循环迭代的I/O回调。
   │  └─────────────┬─────────────┘
   │  ┌─────────────┴─────────────┐
   │  │       idle, prepare       │		# 内部调用 (可忽略)
   │  └─────────────┬─────────────┘      ┌───────────────┐
   │  ┌─────────────┴─────────────┐      │   incoming:   │
   │  │           poll            │<─────┤  connections, │		# 执行与I/O相关的回调（除了关闭回调、定时器回调和setImmediate()之外，几乎所有回调都执行）
   │  └─────────────┬─────────────┘      │   data, etc.  │
   │  ┌─────────────┴─────────────┐      └───────────────┘
   │  │           check           │		# 执⾏ setImmediate 回调
   │  └─────────────┬─────────────┘
   │  ┌─────────────┴─────────────┐
   └──┤      close callbacks      │		# 一些关闭回调，例如socket.on（“关闭”，…）。
      └───────────────────────────┘
   ```

5. **同源策略**

   同源： 协议、域名、端口均相等。非同源会发生跨域。

   由于同源策略的限制，跨域请求发送到后端，后端返回数据时会**被浏览器**的跨域报错拦截。

   **解决跨域：**

   `JSONP`：利用`script，link，img，href，src`不受跨域问题限制。通过标签指向⼀个需要访问的地址并提供⼀个回调函数来接收数据。只⽀持GET⽅法且不安全，且需要前后端配合。

   `postMessage`：这种⽅式通常⽤于获取嵌⼊页⾯中的第三⽅页⾯数据。需要使用到iframe标签（依赖于iframe标签实现A——>B，B——>A的数据交互），A域与B域通过`iframe`标签构建成父子级关系。通过window 提供的 `postMessage` 方法和 `message` 事件实现跨域通信。

   `CORS`：服务端设置 `Access-Control-Allow-Origin `就可以开启 `CORS`。是基于`HTTP1.1`的⼀种跨域解决⽅案。

   代理：一般用于⽣产环境不发⽣跨域，但开发环境发⽣跨域。只需要在开发环境使⽤代理解决跨域。

   `nginx` 代理：反向代理：帮服务器拿到数据，然后选择合适的服务器。和CORS原理同，需要配置请求响应头`Access-Control-Allow-Origin`等字段。把http请求转发到另⼀个或者⼀些服务器上。通过把本地⼀个`url`前缀映射到要跨域访问的web服务器上，就可以实现跨域访问。

   `WebSocket` 协议(与`HTTP`同级)：跨域检测工作就交给了服务端。`WebSocket`请求头信息中有`origin`字段，表⽰请求源⾃哪个域，服务器可以根据这个字段判断是否允许本次通信。

   `document.domain + iframe`：两个域名必须属于同一个一级域名!而且所用的协议，端口都要一致，否则无法利用`document.domain`进行跨域。

   `location.hash + iframe`：A和C同源，A和B非同源，通过C页⾯实现A和B通信。利用`location.hash`传值, 监控hash的变化，执行相应的操作。

   `window.name(共享变量) + iframe`：window.name属性有这样的特点: 当前页设置的值, 在页面重新加载(非同域也可以)后, 值依然不变。给`iframe`赋值跨域的链接，加载完后触发`load`事件，此时`iframe`已经拿到数据放在`window.name`里，因为浏览器同源策略没法直接拿`iframe`的name值，所以将iframe的地址改成同域名下的一个网页，再用`contentWindow`方法获取iframe的name值拿数据，而这个那么是同一个name，所以就实现了跨域。

6. **Content-Type 常见的值**

   - `text/html `： HTML格式
   - `text/plain` ：纯文本格式   
   - `multipart/form-data`   （上传文件的时候，使用的媒体格式类型）
   - `application/x-www-form-urlencoded ` （表单默认的提交数据的格式）
   - `application/json`  ： JSON数据格式

7. **在浏览器输入 URL 回车之后发生了什么？**

   1. URL解析：判断是搜索内容还是请求URL。

   2. 查找缓存：检查本地是否缓存了该请求资源，`expires`和`cache-control`判断是否命中强缓存，`If-Modified-Since(last_modified)`和`If-None-Match(ETag)`判断是否命中协商缓存。

   3. 域名解析：浏览器缓存>系统缓存>hosts⽂件>本地DNS服务器>根域名服务器>顶级域名服务器>权限域名服务器

   4. TCP三次握⼿

      1. 客户端：标志位SYN=1，序号Seq=x，进⼊SYN-SENT状态
      2. 服务器：标志位SYN=1，ACK=1，序号seq=y，确认号ack=x + 1，进入SYN-RCVD状态
      3. 客户端：标志位ACK=1，序号seq=x+1，确认号ack=y+1，进⼊ESTABLISHED状态。服务器端收到确认后，也进⼊ESTABLISHED状态，由此成功建⽴了TCP连接

      三次握手是为了避免服务器等待造成资源浪费。

   5. 发送HTTP请求

   6. 服务器处理请求并返回报⽂

   7. 客户端处理响应，⾸先检查服务器响应报⽂的状态码

   8. TCP四次挥⼿ 关闭TCP连接

      1. 客户端：主动断开连接，标志位FIN=1，序号位seq=u，并停⽌发送数据，进入FIN_WAIT_1状态
      2. 服务器：若还需传输数据，⽆法⽴即关闭连接，先返回⼀个标志位ACK=1，序号seq=v，确认号ack=u+1的数据包，进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态
      3. 服务器：服务器准备好断开连接后，标志位FIN=1，标志位ACK=1，序号seq=w，确认号ack=u+1，进入LAST_ACK状态。
      4. 客户端：客户端收到后返回⼀个标志位ACK=1，序号seq=u+1，确认号ack=w+1的数据包，进入TIME_WAIT状态，需要等待2MSL(`Maximum Segment LifeTime`报文最大生成时间)进入CLOSE状态。服务器收到数据包后直接进入CLOSE状态。

   9. 浏览器解析渲染页⾯

      1. 解析HTML，构建DOM树
      2. 解析CSS，⽣成CSS规则树
      3. 合并DOM树和CSS规则，⽣成render树
      4. 布局render树（Layout/reflow），负责各元素尺⼨、位置的计算
      5. 绘制render树（paint），绘制页⾯像素信息
      6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显⽰在屏幕上

8.  **前端路由**

   搭配SPA单页面应用框架。可以不向后台发送请求而直接通过前端技术实现多个页面的效果。

   前端路由主要有以下两种实现方案：

   - `Hash`：基于 `location.hash` 来实现的，`hash` 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制`hash` 的切换。可以使用 `hashchange` 事件来监听 `hash` 的变化。可以通过你`a`标签或者`js`修改触发`hashchange` 事件。兼容性好，但路径在#后⾯，不美观。
   - `History`：`history.pushState()` 和 `history.repalceState()`。这两个 `API`可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。我们可以使用 `popstate` 事件来监听 `url` 的变化，但通过浏览器前进后退改变 URL 时会触发 `popstate` 事件, 而`pushState()/replaceState()` 不会触发 `popstate` 事件，这时我们需要手动触发页面渲染；简洁美观但需要服务端对路由进行相应配合设置。

9. **前端缓存**

   HTTP缓存：

   - 强缓存：当命中强缓存的时候，客户端不会再请求服务器，直接从缓存中读取内容，并返回HTTP状态码200。在响应头由 `Expires、Cache-Control 和 Pragma`控制，优先级`Pragma > Cache-Control > Expires`。
   - 协商缓存：向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源。响应头中有两个字段标记规则`Last-Modified / If-Modified-Since`、`Etag / If-None-Match`（优先级更高）。

   Memory Cache：内存中的缓存，主要包含的是当前中页⾯中已经抓取到的资源,例如页⾯上已经下载的样式、脚本、图⽚等。会随着进程的释放⽽释放。 ⼀旦我们关闭Tab页⾯，内存中
   的缓存也就被释放了。

   Disk Cache：硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，⽐之 Memory Cache 胜在容量和存储时效性上。

   Push Cache：（推送缓存）是 HTTP/2 中的内容，它只在会话（Session）中存在，⼀旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右。

10. **Cookie**

    重要字段：`name = value` 如果⽤于保存⽤户登录态，赋值 cookie 的名称和值; `expires=datecookie`有效期; `path=path`将服务器上的⽂件⽬录作为cookie的使⽤对象; `domain=域名` cookie适⽤对象的域名, cookie的作用域是domain本⾝以及domain下的所有⼦域名; `HttpOnly`不能通过 JS 访问 Cookie，减少XSS 攻击; `secure`只能在协议为 HTTPS 的请求中携带cookie; `same-site`规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击。

    - 影响性能，最⼤为4kb
    - ⼀个浏览器对于⼀个⽹站只能存不超过20个Cookie，⽽浏览器⼀般只允许存放300个Cookie
    - 移动端对Cookie⽀持不友好
    - ⼀般情况下存储的是纯⽂本，对象需要序列化之后才可以存储，解析需要反序列化

11. **Webstorage**

    `localStorage`：

    - ⽣命周期：持久化的本地存储，除⾮⼿动删除数据，否则数据是永远不会过期的
    - 存储的信息在同⼀域中共享
    - ⼤⼩：5M+，和浏览器⼚商有关
    - 本质上是对字符串的读取，若存储内容过多会消耗内存空间，导致页⾯卡顿
    - 受同源策略限制

    `sessionStorage`：和`localStorage`唯⼀不同就是⽣命周期，⼀旦页⾯关闭，`sessionStorage`将会删除数据。

    `IndexedDB`：扩展的前端存储⽅式，是运⾏在浏览器中的⾮关系型数据库，理论上容量⽆上限。可以理解为`localStorage`的加强版。

12. **权限验证**

    `Cookie`

    `Cookie-session`：`cookie`⼤⼩有限制，所以后端返回`sessionId`，客户端将`sessionid`存在`cookie`中。服务器根据`sessionId`去缓存系统获取⽤户信息和认证。

    `SSO`：`Single Sign On`单点登录，CAS（中央认证服务）原理。

    `Json Web Token`：最简单的 token 组成 :uid( ⽤户唯⼀的⾝份标识 ) 、 time( 当前时间的时间戳 ) 、 sign( 签名，由 token 的前⼏位 + 哈希算法压缩成⼀定长的⼗六进制字符串，防⽌恶意三⽅拼接 token 请求。JWT由header（头部）、payload（负载）、signature（签名）这三个部分组成，中间⽤`.`来分隔开：`Header.Payload.Signature`。 JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。session 和 token 的对⽐就是「⽤不⽤cookie」和「后端存不存」的对⽐。

13. **性能优化**

    1. **从用户角度**，优化能够让页面加载得更快、对用户的操作响应更快，给用户提供更为友好的体验。
    2. **从服务商角度**，优化能够减少页面请求数、或者减小请求所占带宽，节省资源。

    [常见的web前端性能优化方法总结「建议收藏」 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2097537)

    前端性能优化通常包括以下几个方面：

    1. 减少 HTTP 请求次数：将多个 CSS 或 JavaScript 文件合并成一个文件，使用 CSS Sprites 将多个图片合并成一张大图，使用字体图标代替小图片，可以减少 HTTP 请求次数。

    2. 压缩静态资源：使用压缩工具（如 Gzip）对 HTML、CSS、JavaScript 和图片等静态资源进行压缩，可以减少文件大小，提高页面加载速度。

    3. 懒加载：采用图片懒加载技术，在用户滚动到某个位置时才加载图片，避免在页面初始阶段就加载所有图片。

       懒加载：将不关键的资源延后加载——尽量只加载⽤户正 浏览 或即将会 浏览的图⽚。对于图⽚来说，先设置图⽚标签的` src` 属性为⼀张占位图，真实的图⽚资源放⼊⾃定义属性`data-src` 中，当进⼊⾃定义区域时，就将⾃定义属性替换为 `src `属性，这样就会下载图⽚资源。可以搭配`offsetTop、scrollTop`、`Element.getBoundingClientRect()`、`IntersectionObserver API`检测元素是否出现在可视窗。

    4. 避免重绘和回流：尽可能避免频繁的 DOM 操作和样式变化，因为这些操作会导致浏览器进行重绘和回流，降低页面性能。

    5. 使用缓存：对于不经常变动的静态资源，可以通过设置缓存时间来减少服务器请求次数，从而提升页面加载速度。

    6. 代码优化：优化 JavaScript 代码，避免过多的全局变量、循环嵌套等问题，使用事件委托等技术来减少事件绑定次数，提高页面性能。

    7. 使用 CDN：使用内容分发网络（CDN）可以将静态资源缓存在离用户最近的节点上，提高页面加载速度。

       CDN：内容分发⽹络，它是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。静态资源使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个CDN 域名。与传统访问方式不同，CDN网络则是在用户和服务器之间增加缓存层，将用户的访问请求引导到最优的缓存节点而不是服务器源站点，从而加速访问速度。

    下面这个链接从浏览器、资源、图片等方面提出优化方案。

    [web前端性能优化（全汇总） - 掘金 (juejin.cn)](https://juejin.cn/post/7029973323475845150)

    如何渲染几万条数据并不卡住界面：想让几万条数据渲染并且不卡住页面，那么你就需要像大文件上传一样，做到分块渲染，大批量同步渲染，浏览器不卡死才怪呢。
    我们需要尽可能地避免重排（回流）的次数，此时可以考虑使用`createDocumentFragment()`，结合`window.requestAnimationFrame()`。[如何渲染几万条数据并不卡住界面 - 掘金 (juejin.cn)](https://juejin.cn/post/6953501066344267813)

14. **前端安全**

    **XSS跨站脚本攻击：Cross Site Scripting**

    从攻击代码的工作方式可以分为三个类型：

    - 持久型跨站：最直接的危害类型，跨站代码存储在服务器（数据库）。经过后端，经过数据库。
    - 非持久型跨站：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。经过后端，不经过数据库。
    - DOM跨站（DOM XSS）：DOM（document object model文档对象模型），客户端脚本处理逻辑导致的安全问题。

    防范：对输⼊转码过滤、利⽤CSP（浏览器内容安全策略，核⼼就是服务器决定浏览器加载哪些资源）、`HttpOnly`（阻⽌JS对cookie的访问）

    [这一次，彻底理解XSS攻击 - 掘金 (juejin.cn)](https://juejin.cn/post/6912030758404259854)

    **CSRF-跨站伪造请求（钓鱼）：Cross-Site Request Forgery**

    攻击者诱导受害者进⼊第三⽅⽹站，在第三⽅⽹站中，向被攻击⽹站发送跨站请求。利⽤受害者在被攻击⽹站已经获取的注册凭证（⽐如cookie） ，绕过后台的⽤户验证，因此可以冒充⽤户对被攻击的⽹站执⾏某项操作。本质：利⽤ cookie 会在同源请求中携带发送给服务器的特点，以此冒充⽤户。

    防范：`SameSite`（禁⽌第三⽅请求携带Cookie）、验证来源站点（请求头中的`origin`和`referer`信息）、`token`、安全框架(如Spring Security)

    [对于跨站伪造请求（CSRF）的理解和总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37293032)

    **DDoS全称Distributed Denial of Service**

    意思为“分布式拒绝服务”，即利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。

    **HTTPS中间⼈攻击**

    客户端和服务器之间的桥梁、双向获取并且篡改信息。攻击者通过与客户端和客户端的⽬标服务器同时建⽴连接，作为客户端和服务器的桥梁，处理双⽅的数据，整个会话期间的内容⼏乎完全被攻击者控制。攻击者可以拦截双⽅的会话并且插⼊新的数据内容

    [你连 HTTPS 原理都不懂,还讲“中间人攻击”? - 掘金 (juejin.cn)](https://juejin.cn/post/6844904065227292685)
    
15. **HTTP状态码**

    HTTP状态码是Web服务器向客户端返回的三位数的代码，它表示HTTP请求的处理情况。共分为5类，具体介绍如下：

    1xx（信息性状态码）：表示服务器已接收到请求，正在处理中。 

    2xx（成功状态码）：表示服务器已成功接收、理解并处理了请求。

     3xx（重定向状态码）：表示客户端需要进行进一步的操作才能完成请求。

     4xx（客户端错误状态码）：表示客户端提交的请求有误或者不能被服务器所理解。

     5xx（服务器错误状态码）：表示服务器在处理请求时出现了错误。

    常见的状态码包括：

    - 200 OK: 请求成功
    - 301 Moved Permanently: 资源被永久转移
    - 302 Found: 资源被临时转移
    - 307 Temporary Redirect 请求的资源临时从不同的URI 响应请求。
    - 400 Bad Request: 请求错误
    - 401 Unauthorized: 未授权
    - 404 Not Found: 资源未找到
    - 500 Internal Server Error: 服务器内部错误
    - 503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。

    [HTTP状态码最全详解_http状态码设计规范_IT阿剂的博客-CSDN博客](https://blog.csdn.net/qq_42402086/article/details/107491536)

16. **HTTP/2**

    HTTP/2是HTTP协议的第二个主要版本，于2015年发布。它的目标是提高网站性能，并解决HTTP/1.x的一些缺点。HTTP/2引入了许多新功能，例如：

    1. 多路复用：在HTTP/2中，可以同时发送多个请求和响应消息，这可以显著减少页面加载时间。
    2. 二进制分帧：HTTP/2使用二进制格式传输数据，而HTTP/1.x则使用文本格式。这意味着HTTP/2可以更快地处理和传输数据。
    3. 流量控制：HTTP/2支持流量控制，这允许服务器控制每个连接上的数据流量并使得网络资源得到更好的利用。
    4. 首部压缩：HTTP/2允许客户端和服务器使用头部表来存储之前已经发送过的头部信息，这可以减少重复信息的传输，从而降低网络延迟。
    5. 服务器推送: 服务器推送允许服务器在客户端请求之前将相关资源推送给客户端，这可以避免客户端重复发起请求并等待响应，从而进一步提高页面加载速度。

    总的来说，HTTP/2的目标是通过优化数据传输来提高网站性能，从而改善用户体验。

    [HTTP/1.1、HTTP/2、HTTP/3的演变_http/1.1 http2 http3_楠哥学IT的博客-CSDN博客](https://blog.csdn.net/ITCSDN_/article/details/109518671)

17. 

## CSS

1. **CSS属性值百分比**

   - `width/height`: 大部分情况下，参照包含块（父元素）的内容区，width参照width，height参照height。需要注意的是当一个元素的高度使用百分比值，如果其父元素没有明确的高度定义（也就是说，取决于内容高度），且这个元素不是绝对定位，则该百分比值等同于auto。
   - `margin/padding`：对于margin和padding，其**任意方向**的百分比值，参照都是包含块的**宽度**。需要注意的是margin负值：margin-top和margin-left 负值，元素向上、向左移；margin-right 负值，右侧元素左移，自身不受影响；margin-bottom 负值，下方元素上移，自身不受影响。
   - `border-radius`：百分比值，参照物是这个**元素自身的尺寸**。需要注意的一点是border-radius的简写，和padding、margin类似，三个值时，是第二个和第四个值相同。二个值时1，3和2，4相同。

2. **display，opacity，visibility三者之间的区别**

   `display`，`opacity` 和 `visibility` 是用于控制网页元素**可见性**的三个不同的 CSS 属性。

   `display` 属性决定了一个元素在网页上的显示方式。它可以取值为 `block`、`inline`、`none` 等等。当设置为 `display:none` 时，该元素将**从文档中正常流中移除**，并且不会占据任何页面空间。**无法进行DOM事件监听**。会引起**重排、重绘**，性能较差。**不会被子元素继承**，因为子元素也不被渲染。`transtion`过渡不支持display。

   `opacity` 属性用于调整元素的透明度级别。它可以取值介于 0（完全透明）和 1（完全不透明）之间。这个属性不影响页面布局。**可以进行DOM事件监听**。**提升为合成层，不会引发重绘**，性能较高。会被子元素继承，**子元素不能通过设置opacity:1;来取消隐藏**。opacity可以通过`transtion`延时显示与隐藏。visibility的`transtion`会立即显示，隐藏时会延时。

   `visibility` 属性控制一个元素是可见还是隐藏。它可以取值为 `visible`、`hidden`、`collapse`。当一个元素被设置为 `visibility:hidden` 时，它仍然在页面布局中占有空间，但是不可见。**无法进行DOM事件监听。**动态改变此属性时会引起重绘，性能较高。会被子元素继承，子元素通过设置`visibility:visible`来显示自身，使子元素取消自身隐藏。

   总之，`display` 属性影响元素的布局和可见性，`opacity` 属性影响元素的透明度水平，而 `visibility` 属性控制元素是可见还是隐藏并且仍保留其在布局中的位置。

   [display，opacity，visibility三者之间的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/6856383657209724941)

3. **`css`选择器优先级**

   CSS选择器优先级是一种计算方式，它由以下个级别的规则组成，用于确定哪些CSS规则应该被应用于元素，并在多个规则中冲突时解决冲突。CSS选择器的四个级别从高到低分别为：

   1. 内联样式（给元素添加style属性）
   2. ID选择器
   3. 类选择器、属性选择器和伪类选择器
   4. 元素选择器和伪元素选择器

   除此之外还有权重最高的!important

   [CSS 选择器的优先级!important ,style,id,class,标签，后代选择器和子代选择器_css important优先级_草字的博客-CSDN博客](https://blog.csdn.net/qq_42740797/article/details/112003815)

4. **flex布局**

   Flex布局是一种基于盒状模型的布局方式，它可以使容器内的子元素按照一个方向排列，并根据需要自动调整它们在可用空间内的大小。Flex布局的主要思想是将父容器分割成行或列，并通过设置弹性属性来控制子元素的位置、大小和顺序。

   使用flex布局，可以轻松地实现复杂的布局效果，例如：垂直居中、等高布局、流式布局等等。同时，flex布局也很容易实现响应式设计，即根据不同屏幕大小和设备类型调整布局。

   通过设置父容器的 display 属性为 flex 或 inline-flex，可以启用Flex布局。然后可以通过设置各个子元素的 flex 属性来控制它们的弹性表现。Flex布局的容器有以下属性：flex-direction

   •  flex-wrap

   •  flex-flow

   •  justify-content

   •  align-items

   •  align-content。

   常用的Flex布局的项目有以下属性：

   •  order

   •  flex-grow

   •  flex-shrink

   •  flex-basis

   •  flex

   •  align-self

   [flex 布局的基本概念 - CSS：层叠样式表 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)

5. **回流和重绘**

   回流和重绘是前端开发中的两个重要概念。

   回流（reflow）：当Rendering Tree中部分元素的尺寸大小、布局、隐藏等属性改变时，浏览器的布局需要调整，则需要重新渲染DOM。这个过程称为回流，又称为重排。

   重绘（repaint）：当Rendering Tree中元素的属性虽然发生了改变，但没有影响其在布局上的位置时，浏览器只需要把新的样式重新绘制一遍即可，这个过程称为重绘。

   回流和重绘都会导致性能问题，因此我们应该尽量减少它们的发生。

   - 避免逐次改变样式，样式统一批量修改

   - 使DOM脱离文档流，再作批量处理

   - 缓存布局属性（需即时计算的属性）

   - position属性控制其脱离文档流

   - CSS3硬件加速，如transform、opacity、filters

   [回流（重排）与重绘 —— 什么是回流和重绘，造成的原因是什么，如何去减少？_定义重绘_Silam Lin的博客-CSDN博客](https://blog.csdn.net/qq_43263320/article/details/118361602)

6. 

## JavaScript

1. **JS函数的length**

   length 是函数对象的⼀个属性值，指该函数有多少个**必须要传⼊的参数**，即形参的个数。形参的数量不包括剩余参数个数，仅包括第⼀个具有默认值之前的参数个数。

2. **JavaScript解析URL**
   将URL字符串解析为`URL`对象，就可以轻松获取URL的各个部分和查询参数。

   ```js
   const url = "https://www.example.com/path/to/page?query=value#fragment";
   
   // 解析URL
   const parsedUrl = new URL(url);
   
   // 获取各个部分
   const protocol = parsedUrl.protocol; // "https:"
   const hostname = parsedUrl.hostname; // "www.example.com"
   const pathname = parsedUrl.pathname; // "/path/to/page"
   const search = parsedUrl.search; // "?query=value"
   const hash = parsedUrl.hash; // "#fragment"
   
   // 获取查询参数
   const queryParams = new URLSearchParams(search);
   const queryValue = queryParams.get("query"); // "value"
   ```

   正则表达式：

   ```js
   function parseUrl(url) {
     const regex = /^([^:]+):\/\/([^\/]+)(\/[^?#]*)(\?[^#]*)?(#.*)?$/;
     const match = url.match(regex);
   
     if (!match) {
       throw new Error("Invalid URL");
     }
   
     const [_, protocol, hostname, pathname, search, hash] = match;
   
     return {
       protocol,
       hostname,
       pathname,
       search: search || "",
       hash: hash || ""
     };
   }
   ```

   这个正则表达式`/^([^:]+):\/\/([^\/]+)(\/[^?#]*)(\?[^#]*)?(#.*)?$/` 解释如下：

   - `^` 表示匹配字符串的开头。
   - `([^:]+)` 匹配除了冒号以外的任意字符，一个或多个。这个部分用来匹配协议（比如`http`或`https`）。
   - `:\/\/` 匹配冒号和两个斜杠，即协议后面的部分。
   - `([^\/]+)` 匹配除了斜杠以外的任意字符，一个或多个。这个部分用来匹配主机名。
   - `(\/[^?#]*)` 匹配一个斜杠，后面跟着零个或多个非问号和非井号的字符。这个部分用来匹配路径。
   - `(\?[^#]*)?` 匹配一个问号，后面跟着零个或多个非井号的字符。这个部分用来匹配查询字符串。注意这个部分是可选的，因为URL可能没有查询字符串。
   - `(#.*)?` 匹配一个井号，后面跟着零个或多个任意字符。这个部分用来匹配哈希。注意这个部分也是可选的，因为URL可能没有哈希。
   - `$` 表示匹配字符串的结尾。

   query-string库：

   ```js
   import queryString from 'query-string';
   
   const url = "https://www.example.com/path/to/page?query=value&foo=bar#fragment";
   
   // 解析URL的查询参数
   const queryParams = queryString.parseUrl(url).query;
   
   // 将查询参数转换为对象
   const queryObject = queryString.parse(queryParams);
   
   console.log(queryObject); // { query: 'value', foo: 'bar' }
   ```

   还可以直接splice一个个切。

3. **JS正则表达式**

   JavaScript正则表达式是一种强大的字符串匹配工具，用于从文本中查找符合某种模式的字符串。下面是JavaScript正则表达式的一些常用用法：

   创建正则表达式对象

   可以使用`RegExp`对象来创建正则表达式对象：

   ```
   let regExp = new RegExp("pattern");
   ```

   也可以使用字面量形式来创建正则表达式对象：

   ```
   let regExp = /pattern/;
   ```

   其中，"pattern"是正则表达式模式。

   字符类和元字符

   在正则表达式中，一些特殊字符被称为元字符。它们有特殊的含义，比如表示任意字符、匹配数字等。

   另外一些字符被称为字符类，它们用于匹配一组指定的字符。

   例如，下列是一些常用的元字符和字符类：

   - `. (点)`：匹配除换行符以外的任意字符。
   - ^：匹配输入的开始。
   - $：匹配输入的结束
   - `\d`：匹配任意一个数字。
   - `\w`：匹配任意一个字母或数字或下划线。
   - `\s`：匹配任意一个空白字符，包括空格、制表符、换行符等。
   - `[]`：用来定义一个字符集合，匹配其中任意一个字符。
   - `[^]`：用来定义一个反向字符集合，匹配不在其中的任意一个字符。

   量词

   在正则表达式中，可以使用量词来指定一个模式出现的次数。

   例如，下列是一些常用的量词：

   - `*`：匹配前面的模式零次或多次。
   - `+`：匹配前面的模式一次或多次。
   - `?`：匹配前面的模式零次或一次。
   - `{n}`：匹配前面的模式恰好n次。
   - `{n,}`：匹配前面的模式至少n次。
   - `{n,m}`：匹配前面的模式至少n次，但不超过m次。

   匹配方法

   在JavaScript中，有两种主要的正则表达式匹配方法：`test()和exec()`。

   `test()`方法会返回一个布尔值，表示给定的字符串是否匹配某个正则表达式。例如：

   ```
   let regExp = /\d+/;
   console.log(regExp.test("123abc")); // true
   console.log(regExp.test("abc")); // false
   ```

   `exec()`方法会返回一个数组，其中包含了所有与正则表达式匹配的子串以及匹配的位置等信息。例如：

   ```
   let regExp = /(\d+)([a-z]+)/;
   let result = regExp.exec("123abc");
   console.log(result); // ["123abc", "123", "abc"]
   ```

   JavaScript中字符串的正则表达式方法有以下几种：

   `match()`：该方法通过正则表达式匹配字符串，返回一个数组，如果使用 g 标志，则包含所有匹配的子字符串。如果未使用 g 标志，则仅返回第一个完整匹配及其相关的捕获组(和`RegExp.exec()`相同。如果没有匹配到，则返回null。

   示例代码：

   ```
   const str = "hello world";
   const regex = /l+/g;
   const matches = str.match(regex);
   console.log(matches); // ['ll', 'l']
   ```

   `search()`：该方法通过正则表达式在字符串中查找匹配项。如果找到了匹配项，则返回它在字符串中的索引位置。如果没有匹配项，则返回-1。

   `replace()`：该方法通过正则表达式将匹配的子字符串替换成新的字符串。可以使用$1、$2等特殊符号引用正则表达式中的分组内容。

   `split()`：该方法通过正则表达式将字符串分割成子字符串，并将这些子字符串存储在数组中。

   这些都是JavaScript中常用的字符串正则表达式方法。

4. JS常用的新语法

   1. 变量声明：使用let和const关键字来声明变量，其中let声明的变量可以重新赋值，而const声明的变量是不可修改的常量。
   2. 模板字符串：使用反引号（`）来定义模板字符串，可以通过${}来插入变量或表达式，使得字符串拼接更加简洁。
   3. 箭头函数：使用箭头（=>）定义函数，可以避免this指针的问题，并且语法更加简洁。
   4. 解构赋值：可以从数组或对象中提取值并赋给变量，使得代码更加清晰易懂。
   5. 函数参数默认值：可以为函数的参数设置默认值，当未传递参数时会自动使用默认值。
   6. 扩展运算符：使用三个点（...）来表示扩展运算符，可以将数组或对象展开成单独的元素。
   7. 类和继承：使用class关键字定义类，可以方便地实现面向对象编程，并支持继承。
   8. Promise、async/await

   [ES7 到 ES12 常用新语法 - 掘金 (juejin.cn)](https://juejin.cn/post/7007393969994891301)

5. 