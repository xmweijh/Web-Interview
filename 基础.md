## 基本常识

1. **自我介绍**

   您好，我叫*某某某。我目前正在某某大学攻读计算机技术硕士学位。在校期间，获得过某某奖项。并对前端开发产生了浓厚的兴趣，我学习了各类前端技术，并在课余时间积极参加了各种项目和比赛，以提升自己的技能水平。

   作为一个前端实习生，我有以下的技能和经验：

   - 熟练掌握 HTML 和 CSS 布局，能够快速构建响应式网站和应用程序界面
   - 熟悉 JavaScript 语法和基础知识，能够使用原生 JavaScript 开发交互性较强的动态页面
   - 掌握 Vue框架，熟悉组件生命周期、状态管理，能够开发复杂的单页应用程序
   - 熟悉版本控制工具 Git，能够使用 GitHub 进行团队协作和代码托管
   - 具备良好的沟通能力和团队合作精神，能够融入团队并与其他成员紧密合作，共同完成项目

   我非常热爱前端开发工作，并希望能够在您公司进行实习，学习和实践更多的技术，并为公司做出自己的贡献。谢谢！

2. **为什么学前端**

   1. 兴趣所在：前端开发是一个创造性的过程，它可以将设计师的想象力变成真正的网站或应用程序。我一直对良好的用户界面和用户体验产生浓厚的兴趣，这也是我选择学习并入行前端开发的主要原因。
   2. 前景看好：随着互联网的快速发展和普及，前端开发已经成为了市场上最具有竞争力的职业之一。现在许多公司都需要招聘优秀的前端工程师来开发自己的网站和应用程序。因此，我认为前端开发是一个非常有前途和有潜力的领域。
   3. 技术挑战：前端开发涉及到许多不同的技术和工具，如HTML、CSS、JavaScript、UI框架等。对于我这样喜欢学习新知识和探索新技术的人来说，前端开发提供了很好的机会来学习和实践这些技术，并且不断地挑战自己，提升自己的技能水平。
   4. 可以与他人合作：前端开发不仅是独立完成项目的工作，同时也需要与其他团队成员密切合作。前端开发人员需要了解设计师的要求和后端工程师的需求，以确保顺利地完成整个项目。这种协作和沟通的过程对我来说也是一个很好的学习机会，并且可以帮助我成为更好的团队成员。

   总之，选择学习前端开发是因为它与我的兴趣、职业前景、技术挑战和合作机会等方面都非常相符，我相信这是我未来职业生涯的最佳选择。

4. **前端和其它方向的差异**

   前端和其他方向的差异主要体现在以下几个方面：

   1. 技术栈不同：前端开发侧重于 Web 前端技术，主要包括 HTML、CSS 和 JavaScript 等。而其他方向的开发可能会涉及到不同的编程语言和框架，如 Java、Python、Ruby、PHP、C# 等。
   2. 面向对象的程度不同：与 Java 或 Python 这样强调面向对象编程的语言相比，前端开发对面向对象编程的要求较低。虽然 JavaScript 也是一种支持面向对象编程的语言，但前端开发者通常更关注 DOM 操作和事件处理等技术。
   3. 设计和用户体验的角色不同：在前端开发中，设计和用户体验必须考虑得非常全面，因为网站或应用程序的界面直接影响着用户体验。而其他方向的开发更多地关注后端逻辑和数据交互等技术，设计和用户体验往往由专门的 UI 设计师或 UX 设计师来负责。
   4. 发布和部署的方式不同：前端开发需要了解 Web 应用程序的发布和部署，以确保将 Web 页面正确地呈现给用户。而其他方向的开发可能会涉及到不同的环境和部署方式，如云计算、服务器架构等。

   总体来说，虽然不同的开发方向有着各自独特的特点和技术栈，但所有这些领域都需要优秀的编码技能、团队合作精神以及对行业和技术发展趋势的敏锐洞察力。

5. **前端重要的知识有哪些方面**

   前端开发是一个涉及多个领域的综合性工作，其中包含了许多重要的知识点，以下是前端开发中重要的知识方面：

   1. HTML、CSS 和 JavaScript：这三个基础技术是前端开发的核心，掌握它们是非常必要的。
   2. 响应式 Web 设计：响应式设计可以使网站在不同的设备上自适应调整布局和显示效果。对于现代 Web 开发而言，响应式 Web 设计是一项非常重要的技能。
   3. UI 库和框架：如 Bootstrap、Material Design Lite、Foundation 等。使用这些库和框架可以更快地创建页面和应用，并且确保它们具有良好的用户体验和可靠性。
   4. 前端性能优化：前端性能优化包括缩小文件大小、减少 HTTP 请求次数、优化图片、压缩代码等等。理解并掌握这些技术可以使前端性能得到大幅度提升。
   5. 模块化开发：模块化开发是一种组织代码的方式，可以提高代码的复用性、可维护性和可扩展性。常见的模块化开发方案有 CommonJS、AMD 和 ES6 的模块系统等。
   6. 前端安全：了解 Web 安全问题、防范 XSS、CSRF 和 SQL 注入等安全攻击是前端开发必须掌握的知识点。
   7. 浏览器工作原理：了解浏览器工作原理可以帮助我们更好地理解 Web 开发，包括 DOM 树、CSS 渲染树、事件循环等。
   8. 前端工具链：如 Git、Webpack、Babel、LESS、SASS 等。这些工具可以大幅度提高前端开发效率和代码质量。
   9. 单元测试和集成测试：单元测试和集成测试是保证代码质量和应用程序稳定性的重要手段。

   总之，以上这些知识点都是前端开发中非常重要的方面，同时也需要不断学习和更新自己的技能。

5. **职业发展未来规划**

   前端开发是一个快速发展的行业，未来还有很大的发展空间。以下是前端职业发展的一些规划：

   1. 深入学习前端技术：前端技术在不断更新和演进中，掌握新的技术和工具是非常重要的。可以关注各种前端社区，如GitHub、Stack Overflow、Medium等，了解最新的前端技术和趋势。
   2. 掌握跨平台开发技能：随着移动端和桌面端应用的兴起，跨平台开发技能变得越来越重要。可以尝试学习React Native、Flutter、Electron等跨平台开发工具，提高自己的综合能力。
   3. 学习后端技术：掌握后端技术可以帮助前端开发人员更好地理解整个Web开发过程，同时也可以扩展自己的职业领域。可以学习Node.js、Java、Python等后端技术。
   4. 提升团队协作和管理能力：随着团队规模的不断扩大，良好的团队协作和管理能力越来越成为评价一个前端开发人员的重要标准。可以积极参与团队协作，提高自己的沟通能力和管理能力。
   5. 持续学习和自我提升：前端技术在不断发展，需要持续学习和自我提升。可以参加各种在线课程、线下技术交流会议、国际开发者大会等活动，结交更多的业内人士，分享经验和成果。
   
6. **常见的不稳定排序算法**

   在排序算法中，稳定性是指如果在待排序的数组中存在两个相等的元素，在排序后，它们**在数组中的相对位置是否发生变化**。如果相等元素的相对位置没有发生变化，那么这个排序算法就是稳定的；反之，则是不稳定的。

   1. 快速排序：快速排序是一种分治算法，通过划分将待排序数组划分为左右两个子数组，然后递归地对这两个子数组进行排序，最终得到有序数组。但是由于其涉及到元素的交换操作，因此它是不稳定的。
   2. 堆排序：堆排序是利用堆这种数据结构来实现排序的算法。堆分为大根堆和小根堆，大根堆要求每个节点的值都不大于其父节点的值，而小根堆要求每个节点的值都不小于其父节点的值。在堆排序中，我们首先将待排序数组构造成一个堆，然后将堆顶元素与堆底元素交换，并重新调整堆，最终得到有序数组。由于堆排序中涉及到元素的交换操作，因此它也是不稳定的。
   3. 希尔排序：希尔排序是一种改进版的插入排序算法，它通过在原始数据上进行多次排序，每次排序时将数据分成若干个小组，在每个小组内部进行插入排序。希尔排序的不稳定性来源于其间隔序列的选取方式。
   4. 直接选择排序法。基本思想是：第一趟从n个元素的数据序列中选出关键字最小（或最大）的元素并放到最前（或最后）位置，下一趟再从n-1个元素中选出最小（或最大）的元素并放到次前（后）位置，以此类推，经过n-1趟完成排序。涉及到元素的交换操作，因此它也是不稳定的。

   需要注意的是，并不是所有的排序算法都是不稳定的。例如，冒泡排序、插入排序和归并排序等算法都是稳定的排序算法。

7. **`npm`发包，`package.json`有哪些字段**

   在使用npm发包时，package.json文件是必不可少的配置文件之一。它描述了你的项目的元数据，如名称、版本、作者等信息。以下是主要的几个字段：

   1. name：指定包的名称，必须是唯一的。小写字母，可以包含连字符和下划线。
   2. version：指定包的版本号。必须是`x.x.x`的形式，并且遵循语义化版本规则。
   3. description：对包的简单描述。
   4. main：指定包的入口文件，可以是一个JS文件或者一个二进制文件。
   5. keywords：关键词数组，用于搜索和分类。
   6. author：指定包的作者和联系方式。
   7. license：指定包所采用的许可证。
   8. dependencies：指定包的依赖项，以及版本范围。
   9. devDependencies：指定开发环境下的依赖项。
   10. repository：指定代码仓库信息。
   11. bugs：指定软件缺陷跟踪系统的链接地址。
   12. homepage：指定包的主页。
   13.  scripts：脚本命令集合。

   除了这些基本字段外，还可以添加任意的自定义字段来提供其他元数据。

8. **简单介绍OSI七层模型**

   OSI七层模型是指Open System Interconnection（开放式系统互联）参考模型，是一个将通信协议按照一定的规则分层的模型，用于网络通信的标准化和设计。

   OSI七层模型包括以下七个层次：

   1. 物理层（Physical layer）：负责传输比特流，即将数字信息转换为物理信号进行传输。
   2. 数据链路层（Data Link layer）：负责在物理层之上建立数据链路，处理帧的传输。
   3. 网络层（Network layer）：负责将数据包从源地址传输到目的地址，实现网络互连。
   4. 传输层（Transport layer）：提供端到端的可靠数据传输，保证数据完整性、顺序性和可靠性。
   5. 会话层（Session layer）：负责建立、管理和终止会话，为应用程序提供通信服务。
   6. 表示层（Presentation layer）：处理数据格式的表示问题，如加密、压缩等。
   7. 应用层（Application layer）：为用户应用程序提供网络服务，如HTTP、FTP、SMTP等。

   每一层都有自己特定的功能和任务，它们一起工作，完成了网络通信的各个方面。这种分层结构可以使得不同厂商的设备和软件能够在遵循同一标准的情况下进行协作，实现通信互联。

9. **三次握手**

   三次握手是TCP/IP协议中用于建立一个可靠的连接的过程。它是指客户端和服务器之间进行三次通信，以确保双方都能收到对方的信息，并且确认双方都愿意建立连接。

   具体而言，三次握手的过程如下：

   第一步：客户端向服务器发送一个SYN标志的数据包，表示请求建立连接。

   第二步：服务器收到这个数据包后，回复一个ACK标志和一个SYN标志的数据包，表示确认请求并请求建立连接。

   第三步：客户端收到服务器的确认后，再次发送一个ACK标志的数据包，表示连接已经建立。

   这样，双方都能确认对方可以正常通信，而且建立了一个可靠的连接。

   采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。

10. **四次挥手**

    四次挥手是TCP/IP协议中用于关闭一个已经建立的连接的过程。它是指客户端和服务器之间进行四次通信，以确保双方都能正常结束连接。

    具体而言，四次挥手的过程如下：

    第一步：客户端向服务器发送一个FIN标志的数据包，表示请求关闭连接。进入FIN_WAIT_1状态

    第二步：服务器收到这个数据包后，回复一个ACK标志的数据包，表示确认请求并准备关闭连接。此时，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态

    第三步：当服务器准备好关闭连接时，向客户端发送一个FIN标志和一个ACK标志的数据包，表示确认关闭请求并请求关闭连接。进入LAST_ACK状态。

    第四步：客户端收到服务器的确认后，再次发送一个ACK标志的数据包，表示连接已经关闭。进入TIME_WAIT状态。服务器收到后进入CLOSE状态。在等待两个2MSL后客户端进入CLOSE状态。

    这样，双方都能确认对方可以正常结束连接，从而避免了出现数据传输错误或者连接断开等问题。

11. **UDP协议的特点**

    UDP（User Datagram Protocol）是一种无连接的、不可靠的协议，它与TCP/IP协议族的其他协议一样用于Internet中的数据传输。

    UDP协议的主要特点如下：

    1. 无连接性：UDP协议是一种无连接的协议，发送端在发送数据前并不需要和接收端建立连接。因此，UDP协议没有像TCP协议那样的“三次握手”、“四次挥手”，从而减少了网络开销和延迟。
    2. 不可靠性：由于UDP协议不提供数据包的确认、重传等机制，因此它是一种不可靠的协议。这意味着当数据包在传输过程中丢失或者损坏时，UDP协议并不会重新传输，也不会向上层应用程序报告错误。
    3. 简单快速：UDP协议的数据包结构比较简单，没有TCP协议那么复杂。因此，UDP协议的处理效率比TCP协议高，并且能够更好地适应实时通信等应用场景。
    4. 支持广播和多播：UDP协议支持向多个接收端同时发送同一份数据包，这种方式被称为多播。UDP协议还支持将数据包广播到整个网络，这种方式被称为广播。

    总的来说，UDP协议适用于那些对可靠性要求不高，但是需要快速传输、支持广播和多播等特殊应用场景。例如，实时语音、视频通话等应用就广泛使用UDP协议。

12. **TCP协议的特点**

    TCP（Transmission Control Protocol）是一种面向连接的、可靠的协议，它负责在网络中传输数据，保证数据能够安全、准确地到达目标主机。

    TCP协议的主要特点如下：

    1. 面向连接性：TCP协议是一种面向连接的协议，发送端在发送数据前需要先和接收端建立连接，并在传输过程中维护这个连接状态。因此，TCP协议比UDP协议更为可靠，可以保证数据的正确性和完整性。
    2. 可靠性：TCP协议提供了数据包确认、重传等机制，当数据包在传输过程中丢失或者损坏时，TCP协议会重新传输数据包，以确保数据能够准确无误地到达接收端。
    3. 流控制和拥塞控制：TCP协议还提供了流控制和拥塞控制机制，以避免数据包在网络中的拥堵和丢失，从而使得TCP协议能够在高速、拥挤的网络环境中稳定运行。
    4. 高效性：TCP协议利用了滑动窗口、分节和快速重传等技术，使得数据能够高效地传输，同时也减少了网络开销和延迟。
    5. 应用广泛：TCP协议是互联网上应用最广泛的协议之一，被广泛应用于Web浏览器、邮件传输、文件传输等各种应用场景。

    总的来说，TCP协议适用于对数据可靠性有严格要求的应用场景，例如网页浏览、文件传输、电子邮件等。虽然TCP协议在效率方面不如UDP协议，但是它更为可靠和安全。

13. **HTTP协议**

    HTTP（Hyper Text Transfer Protocol）是一种用于传输Web页面等数据的协议。它是一个客户端/服务器模型，客户端发送请求给服务器，服务器将响应返回给客户端。HTTP通常运行在TCP/IP协议栈之上，使用TCP作为其传输层协议。

    HTTP协议的主要特点如下：

    1. 简单：HTTP协议的数据包结构比较简单，只需要包含请求头、请求体、响应头和响应体四个部分即可完成基本的通信过程。
    2. 无状态：HTTP协议是一种无状态的协议，每个请求都是独立的，服务器并不会保存客户端的状态信息。这意味着，客户端与服务器之间的每个请求都是相互独立的，服务器并不能知道两个请求是否来自同一个客户端。
    3. 可扩展性：HTTP协议具有良好的可扩展性，可以通过添加新的方法、头部字段等方式实现功能的扩展。
    4. 明文传输：HTTP协议中传输的数据都是明文的，如果被第三方截获，就可能会被窃听或者篡改。
    5. 连接方式多样：HTTP协议支持多种连接方式，包括长连接、短连接、管线化等。

    总的来说，HTTP协议是Web应用程序必须的基础协议之一，它为Web应用程序提供了可靠的数据传输通道。同时，HTTP协议的简单性和可扩展性也为开发人员提供了便利，使得Web应用程序能够更加灵活、高效地运行。

14. **HTTP状态码**

    HTTP状态码是Web服务器向客户端返回的三位数的代码，它表示HTTP请求的处理情况。共分为5类，具体介绍如下：

    1xx（信息性状态码）：表示服务器已接收到请求，正在处理中。 

    2xx（成功状态码）：表示服务器已成功接收、理解并处理了请求。

     3xx（重定向状态码）：表示客户端需要进行进一步的操作才能完成请求。

     4xx（客户端错误状态码）：表示客户端提交的请求有误或者不能被服务器所理解。

     5xx（服务器错误状态码）：表示服务器在处理请求时出现了错误。

    常见的状态码包括：

    - 200 OK: 请求成功
    - 301 Moved Permanently: 资源被永久转移
    - 302 Found: 资源被临时转移
    - 307 Temporary Redirect 请求的资源临时从不同的URI 响应请求。
    - 400 Bad Request: 请求错误
    - 401 Unauthorized: 未授权
    - 404 Not Found: 资源未找到
    - 500 Internal Server Error: 服务器内部错误
    - 503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。

    [HTTP状态码最全详解_http状态码设计规范_IT阿剂的博客-CSDN博客](https://blog.csdn.net/qq_42402086/article/details/107491536)

15. **HTTP/2**

    HTTP/2是HTTP协议的第二个主要版本，于2015年发布。它的目标是提高网站性能，并解决HTTP/1.x的一些缺点。HTTP/2引入了许多新功能，例如：

    1. 多路复用：在HTTP/2中，可以同时发送多个请求和响应消息，这可以显著减少页面加载时间。
    2. 二进制分帧：HTTP/2使用二进制格式传输数据，而HTTP/1.x则使用文本格式。这意味着HTTP/2可以更快地处理和传输数据。
    3. 流量控制：HTTP/2支持流量控制，这允许服务器控制每个连接上的数据流量并使得网络资源得到更好的利用。
    4. 首部压缩：HTTP/2允许客户端和服务器使用头部表来存储之前已经发送过的头部信息，这可以减少重复信息的传输，从而降低网络延迟。
    5. 服务器推送: 服务器推送允许服务器在客户端请求之前将相关资源推送给客户端，这可以避免客户端重复发起请求并等待响应，从而进一步提高页面加载速度。

    总的来说，HTTP/2的目标是通过优化数据传输来提高网站性能，从而改善用户体验。

    [HTTP/1.1、HTTP/2、HTTP/3的演变_http/1.1 http2 http3_楠哥学IT的博客-CSDN博客](https://blog.csdn.net/ITCSDN_/article/details/109518671)

16. **HTTP请求方法**

    HTTP请求方法指的是客户端向服务器发起HTTP请求时所使用的方法。常见的HTTP请求方法包括：

    1. GET：用于请求获取资源，可以附带请求参数在URL中。
    2. POST：用于请求提交数据，通常用于提交表单或上传文件等操作。
    3. PUT：用于请求更新或替换指定资源。
    4. DELETE：用于请求删除指定资源。
    5. HEAD：类似于GET请求，但只返回响应头部信息，不返回响应体。
    6. OPTIONS：请求获取支持的HTTP方法列表和服务器支持的各种选项。

17. **POST与GET请求的区别**

    POST和GET请求是HTTP协议中常用的两种请求方法，它们的主要区别在于：

    1. GET请求会将参数附加到URL后面以查询字符串的形式发送给服务端，而POST请求则将参数包含在请求体中发送给服务端。
    2. GET请求的数据传输量较小，一般用于获取数据；而POST请求的数据传输量较大，一般用于提交数据。
    3. GET请求可以被缓存，POST请求不会被缓存。
    4. GET请求产生一个TCP数据包，而POST请求产生两个TCP数据包
    5. GET请求的安全性较低，因为参数附加到URL上，容易被拦截和篡改。而POST请求的安全性相对较高，因为参数包含在请求体中，不易被拦截和篡改。
    6. GET请求可以直接通过浏览器地址栏进行访问，而POST请求需要通过表单或其他方式进行提交。

    总的来说，GET请求适合用于查询数据，而POST请求适合用于提交数据。同时，由于POST请求的数据传输量较大且安全性较高，因此在涉及敏感数据的场合，建议使用POST请求。

    [get请求和post请求的区别（全面讲解）__处女座程序员的日常的博客-CSDN博客](https://blog.csdn.net/qq_42931285/article/details/119852294)

18. **HTTPS**

    HTTPS（Hypertext Transfer Protocol Secure）是HTTP协议的安全版本，通过在传输层加入SSL/TLS协议进行加密以提供对数据传输的保护。

    HTTPS的工作原理如下：

    1. 客户端向服务器发起连接请求，并发送自己支持的加密算法列表。
    2. 服务器从客户端支持的算法列表中选取一种加密算法，并将该算法信息和自己的数字证书返回给客户端。
    3. 客户端验证服务器的数字证书，如果有效则使用服务器公钥进行加密，并发送加密后的随机数作为“预主密钥”（pre-master secret）。
    4. 服务器使用自己私钥解密预主密钥，然后使用预主密钥生成一个“主密钥”（master secret），用于加密会话过程中的所有信息。
    5. 客户端和服务器共同使用主密钥对通信过程中的所有数据进行加密和解密。

    在上述过程中，数字证书用于验证服务器的真实性，预主密钥用于生成主密钥。同时，客户端和服务器协商好的加密算法可以是对称加密算法、非对称加密算法或两者结合使用的混合加密算法，具体取决于算法的安全性和效率等因素。

    HTTPS相对于HTTP的优势在于：

    1. 数据传输过程中采用加密技术，可以有效防止数据被篡改、窃听或伪造。
    2. HTTPS可以验证网站的真实性，确保用户访问的是目标网站而非恶意网站。
    3. 当前主流浏览器都支持HTTPS，使用HTTPS可以提高网站的可信度和搜索引擎排名。

    总之，HTTPS是一种安全的通信协议，适用于需要保护数据安全和隐私的网站。

    [Https协议详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/30b8b40a671c)

    [深入理解HTTPS工作原理 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903830916694030)

19. **进程和线程**

    进程和线程是操作系统中的两个重要概念，它们都可以执行任务，但是有一些区别。

    进程（Process）是计算机中资源分配和调度的基本单位。一个进程可以包括多个线程，同时也可以通过fork()等系统调用创建新的进程。每个进程都有独立的内存空间、代码段和数据段，进程之间通常需要通过一些IPC（进程间通信）的机制来交换信息。由于进程间切换会涉及到切换上下文等操作，因此进程的创建和销毁相对较为耗时。

    线程（Thread）是指进程内部的执行单元，一个进程中可以创建多个线程。不同的线程共享进程的代码段、数据段和堆栈段，但是每个线程都有自己的寄存器、栈空间和程序计数器。由于线程可以共享进程的资源，因此线程的创建和销毁相对较为轻量级。

    简单来说，进程是资源分配和拥有的单位，而线程是处理器调度的基本单位。

    在实际应用中，进程和线程的选择取决于具体的场景和需求。如果需要进行并行处理或者资源隔离等操作，可以选择使用进程；如果需要利用多核CPU提升单个任务的效率，可以选择使用线程。同时，由于进程间切换代价较高，因此尽可能地减少进程间切换是提升系统性能的重要手段。

20. **进程与线程的状态**

    进程和线程都有自己的状态，通常可以分为以下几种：

    进程大致分为 5 种状态

    - 创建状态(new) ：进程正在被创建，尚未到就绪状态。

    - 就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。

    - 运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。

    - 阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。

    - 结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

    线程状态：

    - 初识状态（new）：新创建了一个线程对象，但还没有调用start()方法时。

    - 运行状态（runnable）：线程调度程序从可运行池中选择一个线程获得CPU时间片后，被选中线程进入的状态。这也是线程进入运行状态的唯一一种方式。

    - 阻塞状态（blocked）：阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

    - 等待状态（waiting）： 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。

    - 超时等待状态（timed_waiting）：处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。

    - 终止状态（terminated）：当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。

    [进程与线程概念、状态转换、通信方式区别 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143058286)

21. 

## HTML与浏览器

1. **为什么 `setTimeout `不阻塞后⾯程序的运⾏？**

   因为 `setTimeout `不是由` js` 引擎线程完成的，是由定时器触发线程完成的，所以它们可以同时进⾏，那么定时器触发线程在这定时任务完成之后会通知事件触发线程往任务队列⾥添加事件。同理，也有异步` HTTP` 请求线程。

2. **常见的异步场景？**

   1. 定时器
   2. 网络请求
   3. 事件绑定
   4. Promise

3. **Event Loop 事件循环**

   记住script本身是宏任务，在这个过程中可能会创建微任务。

   先执行宏任务，再执行产生的所有微任务。（微任务在宏任务之间执行）

   - **常见的宏任务：**`script`整体代码、`setTimeout` 和 `setInterval`（`setImmediate`：`node` 的⽅法）、`requestAnimationFrame`、`I/O`、`UI rendering`

   - **常见的微任务：**`process.nextTick (Node环境中)`、`Promise callback`(例如 `promise.then`)、`MutationObserver`

   举例：主程序和 `setTimeout `都是宏任务，`promise `是微任务，第⼀个宏任务（主程序）执⾏完，执⾏全部的微任务（`promise`），再执⾏下⼀个宏任务
   （`setTimeout`）。

   还需要注意：await是等待，需要把**当前队列中的所有微任务执⾏完**，再执⾏await下面的内容。而await下⾯的内容执⾏完，才⼜执⾏宏任务。

   简述Event Loop 事件循环：Event Loop 事件循环是指浏览器或Node的一种解决JavaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。JavaScript是单线程的，即一次只能执行一个任务，而Event Loop就是用来协调任务执行的机制。当我们执行一个异步操作时，会将其放到Web API中，等合适的时候放入任务队列。当事件循环开始时，会先执行当前调用栈中的所有同步任务。在任务执行期间，如果产生了宏任务，会添加到宏任务队列。如果产生了微任务，那么这些微任务会被添加到微任务队列中，并在当前宏任务执行完毕后立即执行。如果在微任务执行期间产生了新的微任务，则这些新的微任务也会被添加到微任务队列中。只有当微任务队列为空时，才会去执行下一个宏任务。这个过程会一直持续下去，直到所有的任务都被处理完毕。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

   [JavaScript之彻底理解EventLoop - 掘金 (juejin.cn)](https://juejin.cn/post/7020328988715270157)

   [JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2014/10/event-loop.html)

4. **node.js 事件循环**

   ```
      ┌───────────────────────────┐
   ┌─>│           timers          │       # 执⾏ setTimeout 和 setInterval 的回调
   │  └─────────────┬─────────────┘		
   │  ┌─────────────┴─────────────┐
   │  │     pending callbacks     │		# 执行推迟到下一个循环迭代的I/O回调。
   │  └─────────────┬─────────────┘
   │  ┌─────────────┴─────────────┐
   │  │       idle, prepare       │		# 内部调用 (可忽略)
   │  └─────────────┬─────────────┘      ┌───────────────┐
   │  ┌─────────────┴─────────────┐      │   incoming:   │
   │  │           poll            │<─────┤  connections, │		# 执行与I/O相关的回调（除了关闭回调、定时器回调和setImmediate()之外，几乎所有回调都执行）
   │  └─────────────┬─────────────┘      │   data, etc.  │
   │  ┌─────────────┴─────────────┐      └───────────────┘
   │  │           check           │		# 执⾏ setImmediate 回调
   │  └─────────────┬─────────────┘
   │  ┌─────────────┴─────────────┐
   └──┤      close callbacks      │		# 一些关闭回调，例如socket.on（“关闭”，…）。
      └───────────────────────────┘
   ```

5. **同源策略**

   同源： 协议、域名、端口均相等。非同源会发生跨域。

   由于同源策略的限制，跨域请求发送到后端，后端返回数据时会**被浏览器**的跨域报错拦截。

   **解决跨域：**

   `JSONP`：利用`script，link，img，href，src`不受跨域问题限制。通过标签指向⼀个需要访问的地址并提供⼀个回调函数来接收数据。只⽀持GET⽅法且不安全，且需要前后端配合。

   `postMessage`：这种⽅式通常⽤于获取嵌⼊页⾯中的第三⽅页⾯数据。需要使用到iframe标签（依赖于iframe标签实现A——>B，B——>A的数据交互），A域与B域通过`iframe`标签构建成父子级关系。通过window 提供的 `postMessage` 方法和 `message` 事件实现跨域通信。

   `CORS`：服务端设置 `Access-Control-Allow-Origin `就可以开启 `CORS`。是基于`HTTP1.1`的⼀种跨域解决⽅案。

   代理：一般用于⽣产环境不发⽣跨域，但开发环境发⽣跨域。只需要在开发环境使⽤代理解决跨域。

   `nginx` 代理：反向代理：帮服务器拿到数据，然后选择合适的服务器。和CORS原理同，需要配置请求响应头`Access-Control-Allow-Origin`等字段。把http请求转发到另⼀个或者⼀些服务器上。通过把本地⼀个`url`前缀映射到要跨域访问的web服务器上，就可以实现跨域访问。

   `WebSocket` 协议(与`HTTP`同级)：跨域检测工作就交给了服务端。`WebSocket`请求头信息中有`origin`字段，表⽰请求源⾃哪个域，服务器可以根据这个字段判断是否允许本次通信。

   `document.domain + iframe`：两个域名必须属于同一个一级域名!而且所用的协议，端口都要一致，否则无法利用`document.domain`进行跨域。

   `location.hash + iframe`：A和C同源，A和B非同源，通过C页⾯实现A和B通信。利用`location.hash`传值, 监控hash的变化，执行相应的操作。

   `window.name(共享变量) + iframe`：window.name属性有这样的特点: 当前页设置的值, 在页面重新加载(非同域也可以)后, 值依然不变。给`iframe`赋值跨域的链接，加载完后触发`load`事件，此时`iframe`已经拿到数据放在`window.name`里，因为浏览器同源策略没法直接拿`iframe`的name值，所以将iframe的地址改成同域名下的一个网页，再用`contentWindow`方法获取iframe的name值拿数据，而这个那么是同一个name，所以就实现了跨域。

6. **Content-Type 常见的值**

   - `text/html `： HTML格式
   - `text/plain` ：纯文本格式   
   - `multipart/form-data`   （上传文件的时候，使用的媒体格式类型）
   - `application/x-www-form-urlencoded ` （表单默认的提交数据的格式）
   - `application/json`  ： JSON数据格式

7. **在浏览器输入 URL 回车之后发生了什么？**

   1. URL解析：判断是搜索内容还是请求URL。

   2. 查找缓存：检查本地是否缓存了该请求资源，`expires`和`cache-control`判断是否命中强缓存，`If-Modified-Since(last_modified)`和`If-None-Match(ETag)`判断是否命中协商缓存。

   3. 域名解析：浏览器缓存>系统缓存>hosts⽂件>本地DNS服务器>根域名服务器>顶级域名服务器>权限域名服务器

   4. TCP三次握⼿

      1. 客户端：标志位SYN=1，序号Seq=x，进⼊SYN-SENT状态
      2. 服务器：标志位SYN=1，ACK=1，序号seq=y，确认号ack=x + 1，进入SYN-RCVD状态
      3. 客户端：标志位ACK=1，序号seq=x+1，确认号ack=y+1，进⼊ESTABLISHED状态。服务器端收到确认后，也进⼊ESTABLISHED状态，由此成功建⽴了TCP连接

      三次握手是为了避免服务器等待造成资源浪费。

   5. 发送HTTP请求

   6. 服务器处理请求并返回报⽂

   7. 客户端处理响应，⾸先检查服务器响应报⽂的状态码

   8. TCP四次挥⼿ 关闭TCP连接

      1. 客户端：主动断开连接，标志位FIN=1，序号位seq=u，并停⽌发送数据，进入FIN_WAIT_1状态
      2. 服务器：若还需传输数据，⽆法⽴即关闭连接，先返回⼀个标志位ACK=1，序号seq=v，确认号ack=u+1的数据包，进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态
      3. 服务器：服务器准备好断开连接后，标志位FIN=1，标志位ACK=1，序号seq=w，确认号ack=u+1，进入LAST_ACK状态。
      4. 客户端：客户端收到后返回⼀个标志位ACK=1，序号seq=u+1，确认号ack=w+1的数据包，进入TIME_WAIT状态，需要等待2MSL(`Maximum Segment LifeTime`报文最大生成时间)进入CLOSE状态。服务器收到数据包后直接进入CLOSE状态。

   9. 浏览器解析渲染页⾯

      1. 解析HTML，构建DOM树
      2. 解析CSS，⽣成CSS规则树
      3. 合并DOM树和CSS规则，⽣成render树
      4. 布局render树（Layout/reflow），负责各元素尺⼨、位置的计算
      5. 绘制render树（paint），绘制页⾯像素信息
      6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显⽰在屏幕上

8.  **前端路由**

   搭配SPA单页面应用框架。可以不向后台发送请求而直接通过前端技术实现多个页面的效果。

   前端路由主要有以下两种实现方案：

   - `Hash`：基于 `location.hash` 来实现的，`hash` 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制`hash` 的切换。可以使用 `hashchange` 事件来监听 `hash` 的变化。可以通过你`a`标签或者`js`修改触发`hashchange` 事件。兼容性好，但路径在#后⾯，不美观。
   - `History`：`history.pushState()` 和 `history.repalceState()`。这两个 `API`可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。我们可以使用 `popstate` 事件来监听 `url` 的变化，但通过浏览器前进后退改变 URL 时会触发 `popstate` 事件, 而`pushState()/replaceState()` 不会触发 `popstate` 事件，这时我们需要手动触发页面渲染；简洁美观但需要服务端对路由进行相应配合设置。

9. **前端缓存**

   HTTP缓存：

   - 强缓存：当命中强缓存的时候，客户端不会再请求服务器，直接从缓存中读取内容，并返回HTTP状态码200。在响应头由 `Expires、Cache-Control 和 Pragma`控制，优先级`Pragma > Cache-Control > Expires`。
   - 协商缓存：向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源。响应头中有两个字段标记规则`Last-Modified / If-Modified-Since`、`Etag / If-None-Match`（优先级更高）。

   [图解 HTTP 缓存_前端_政采云前端团队_InfoQ精选文章](https://www.infoq.cn/article/aiwqlgtlk2eft5yi7doy)

   [HTTP 缓存 - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)

   Memory Cache：内存中的缓存，主要包含的是当前中页⾯中已经抓取到的资源,例如页⾯上已经下载的样式、脚本、图⽚等。会随着进程的释放⽽释放。 ⼀旦我们关闭Tab页⾯，内存中
   的缓存也就被释放了。

   Disk Cache：硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，⽐之 Memory Cache 胜在容量和存储时效性上。

   Push Cache：（推送缓存）是 HTTP/2 中的内容，它只在会话（Session）中存在，⼀旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右。

10. **Cookie**

    重要字段：`name = value` 如果⽤于保存⽤户登录态，赋值 cookie 的名称和值; `expires=datecookie`有效期; `path=path`将服务器上的⽂件⽬录作为cookie的使⽤对象; `domain=域名` cookie适⽤对象的域名, cookie的作用域是domain本⾝以及domain下的所有⼦域名; `HttpOnly`不能通过 JS 访问 Cookie，减少XSS 攻击; `secure`只能在协议为 HTTPS 的请求中携带cookie; `same-site`规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击。

    - 影响性能，最⼤为4kb
    - ⼀个浏览器对于⼀个⽹站只能存不超过20个Cookie，⽽浏览器⼀般只允许存放300个Cookie
    - 移动端对Cookie⽀持不友好
    - ⼀般情况下存储的是纯⽂本，对象需要序列化之后才可以存储，解析需要反序列化

11. **Webstorage**

    `localStorage`：

    - ⽣命周期：持久化的本地存储，除⾮⼿动删除数据，否则数据是永远不会过期的
    - 存储的信息在同⼀域中共享
    - ⼤⼩：5M+，和浏览器⼚商有关
    - 本质上是对字符串的读取，若存储内容过多会消耗内存空间，导致页⾯卡顿
    - 受同源策略限制

    `sessionStorage`：和`localStorage`唯⼀不同就是⽣命周期，⼀旦页⾯关闭，`sessionStorage`将会删除数据。

    `IndexedDB`：扩展的前端存储⽅式，是运⾏在浏览器中的⾮关系型数据库，理论上容量⽆上限。可以理解为`localStorage`的加强版。

12. **权限验证**

    `Cookie`

    `Cookie-session`：`cookie`⼤⼩有限制，所以后端返回`sessionId`，客户端将`sessionid`存在`cookie`中。服务器根据`sessionId`去缓存系统获取⽤户信息和认证。

    `SSO`：`Single Sign On`单点登录，CAS（中央认证服务）原理。

    `Json Web Token`：最简单的 token 组成 :uid( ⽤户唯⼀的⾝份标识 ) 、 time( 当前时间的时间戳 ) 、 sign( 签名，由 token 的前⼏位 + 哈希算法压缩成⼀定长的⼗六进制字符串，防⽌恶意三⽅拼接 token 请求。JWT由header（头部）、payload（负载）、signature（签名）这三个部分组成，中间⽤`.`来分隔开：`Header.Payload.Signature`。 JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。session 和 token 的对⽐就是「⽤不⽤cookie」和「后端存不存」的对⽐。

13. **性能优化**

    1. **从用户角度**，优化能够让页面加载得更快、对用户的操作响应更快，给用户提供更为友好的体验。
    2. **从服务商角度**，优化能够减少页面请求数、或者减小请求所占带宽，节省资源。

    [常见的web前端性能优化方法总结「建议收藏」 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2097537)

    前端性能优化通常包括以下几个方面：

    1. 减少 HTTP 请求次数：将多个 CSS 或 JavaScript 文件合并成一个文件，使用 CSS Sprites 将多个图片合并成一张大图，使用字体图标代替小图片，可以减少 HTTP 请求次数。

    2. 压缩静态资源：使用压缩工具（如 Gzip）对 HTML、CSS、JavaScript 和图片等静态资源进行压缩，可以减少文件大小，提高页面加载速度。

    3. 懒加载：采用图片懒加载技术，在用户滚动到某个位置时才加载图片，避免在页面初始阶段就加载所有图片。

       懒加载：将不关键的资源延后加载——尽量只加载⽤户正 浏览 或即将会 浏览的图⽚。对于图⽚来说，先设置图⽚标签的` src` 属性为⼀张占位图，真实的图⽚资源放⼊⾃定义属性`data-src` 中，当进⼊⾃定义区域时，就将⾃定义属性替换为 `src `属性，这样就会下载图⽚资源。可以搭配`offsetTop、scrollTop`、`Element.getBoundingClientRect()`、`IntersectionObserver API`检测元素是否出现在可视窗。

    4. 避免重绘和回流：尽可能避免频繁的 DOM 操作和样式变化，因为这些操作会导致浏览器进行重绘和回流，降低页面性能。

    5. 使用缓存：对于不经常变动的静态资源，可以通过设置缓存时间来减少服务器请求次数，从而提升页面加载速度。

    6. 代码优化：优化 JavaScript 代码，避免过多的全局变量、循环嵌套等问题，使用事件委托等技术来减少事件绑定次数，提高页面性能。

    7. 使用 CDN：使用内容分发网络（CDN）可以将静态资源缓存在离用户最近的节点上，提高页面加载速度。

       CDN：内容分发⽹络，它是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。静态资源使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个CDN 域名。与传统访问方式不同，CDN网络则是在用户和服务器之间增加缓存层，将用户的访问请求引导到最优的缓存节点而不是服务器源站点，从而加速访问速度。

    下面这个链接从浏览器、资源、图片等方面提出优化方案。

    [web前端性能优化（全汇总） - 掘金 (juejin.cn)](https://juejin.cn/post/7029973323475845150)

    如何渲染几万条数据并不卡住界面：想让几万条数据渲染并且不卡住页面，那么你就需要像大文件上传一样，做到分块渲染，大批量同步渲染，浏览器不卡死才怪呢。
    我们需要尽可能地避免重排（回流）的次数，此时可以考虑使用`createDocumentFragment()`，结合`window.requestAnimationFrame()`。[如何渲染几万条数据并不卡住界面 - 掘金 (juejin.cn)](https://juejin.cn/post/6953501066344267813)

14. **前端安全**

    **XSS跨站脚本攻击：Cross Site Scripting**

    从攻击代码的工作方式可以分为三个类型：

    - 持久型跨站：最直接的危害类型，跨站代码存储在服务器（数据库）。经过后端，经过数据库。
    - 非持久型跨站：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。经过后端，不经过数据库。
    - DOM跨站（DOM XSS）：DOM（document object model文档对象模型），客户端脚本处理逻辑导致的安全问题。

    防范：对输⼊转码过滤、利⽤CSP（浏览器内容安全策略，核⼼就是服务器决定浏览器加载哪些资源）、`HttpOnly`（阻⽌JS对cookie的访问）

    [这一次，彻底理解XSS攻击 - 掘金 (juejin.cn)](https://juejin.cn/post/6912030758404259854)

    **CSRF-跨站伪造请求（钓鱼）：Cross-Site Request Forgery**

    攻击者诱导受害者进⼊第三⽅⽹站，在第三⽅⽹站中，向被攻击⽹站发送跨站请求。利⽤受害者在被攻击⽹站已经获取的注册凭证（⽐如cookie） ，绕过后台的⽤户验证，因此可以冒充⽤户对被攻击的⽹站执⾏某项操作。本质：利⽤ cookie 会在同源请求中携带发送给服务器的特点，以此冒充⽤户。

    防范：`SameSite`（禁⽌第三⽅请求携带Cookie）、验证来源站点（请求头中的`origin`和`referer`信息）、`token`、安全框架(如Spring Security)

    [对于跨站伪造请求（CSRF）的理解和总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37293032)

    **DDoS全称Distributed Denial of Service**

    意思为“分布式拒绝服务”，即利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。

    **HTTPS中间⼈攻击**

    客户端和服务器之间的桥梁、双向获取并且篡改信息。攻击者通过与客户端和客户端的⽬标服务器同时建⽴连接，作为客户端和服务器的桥梁，处理双⽅的数据，整个会话期间的内容⼏乎完全被攻击者控制。攻击者可以拦截双⽅的会话并且插⼊新的数据内容

    [你连 HTTPS 原理都不懂,还讲“中间人攻击”? - 掘金 (juejin.cn)](https://juejin.cn/post/6844904065227292685)
    
15. 

## CSS

1. **CSS属性值百分比**

   - `width/height`: 大部分情况下，参照包含块（父元素）的内容区，width参照width，height参照height。需要注意的是当一个元素的高度使用百分比值，如果其父元素没有明确的高度定义（也就是说，取决于内容高度），且这个元素不是绝对定位，则该百分比值等同于auto。
   - `margin/padding`：对于margin和padding，其**任意方向**的百分比值，参照都是包含块的**宽度**。需要注意的是margin负值：margin-top和margin-left 负值，元素向上、向左移；margin-right 负值，右侧元素左移，自身不受影响；margin-bottom 负值，下方元素上移，自身不受影响。
   - `border-radius`：百分比值，参照物是这个**元素自身的尺寸**。需要注意的一点是border-radius的简写，和padding、margin类似，三个值时，是第二个和第四个值相同。二个值时1，3和2，4相同。

2. **display，opacity，visibility三者之间的区别**

   `display`，`opacity` 和 `visibility` 是用于控制网页元素**可见性**的三个不同的 CSS 属性。

   `display` 属性决定了一个元素在网页上的显示方式。它可以取值为 `block`、`inline`、`none` 等等。当设置为 `display:none` 时，该元素将**从文档中正常流中移除**，并且不会占据任何页面空间。**无法进行DOM事件监听**。会引起**重排、重绘**，性能较差。**不会被子元素继承**，因为子元素也不被渲染。`transtion`过渡不支持display。

   `opacity` 属性用于调整元素的透明度级别。它可以取值介于 0（完全透明）和 1（完全不透明）之间。这个属性不影响页面布局。**可以进行DOM事件监听**。**提升为合成层，不会引发重绘**，性能较高。会被子元素继承，**子元素不能通过设置opacity:1;来取消隐藏**。opacity可以通过`transtion`延时显示与隐藏。visibility的`transtion`会立即显示，隐藏时会延时。

   `visibility` 属性控制一个元素是可见还是隐藏。它可以取值为 `visible`、`hidden`、`collapse`。当一个元素被设置为 `visibility:hidden` 时，它仍然在页面布局中占有空间，但是不可见。**无法进行DOM事件监听。**动态改变此属性时会引起重绘，性能较高。会被子元素继承，子元素通过设置`visibility:visible`来显示自身，使子元素取消自身隐藏。

   总之，`display` 属性影响元素的布局和可见性，`opacity` 属性影响元素的透明度水平，而 `visibility` 属性控制元素是可见还是隐藏并且仍保留其在布局中的位置。

   [display，opacity，visibility三者之间的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/6856383657209724941)

3. **`css`选择器优先级**

   CSS选择器优先级是一种计算方式，它由以下个级别的规则组成，用于确定哪些CSS规则应该被应用于元素，并在多个规则中冲突时解决冲突。CSS选择器的四个级别从高到低分别为：

   1. 内联样式（给元素添加style属性）
   2. ID选择器
   3. 类选择器、属性选择器和伪类选择器
   4. 元素选择器和伪元素选择器

   除此之外还有权重最高的!important

   [CSS 选择器的优先级!important ,style,id,class,标签，后代选择器和子代选择器_css important优先级_草字的博客-CSDN博客](https://blog.csdn.net/qq_42740797/article/details/112003815)

4. **flex布局**

   Flex布局是一种基于盒状模型的布局方式，它可以使容器内的子元素按照一个方向排列，并根据需要自动调整它们在可用空间内的大小。Flex布局的主要思想是将父容器分割成行或列，并通过设置弹性属性来控制子元素的位置、大小和顺序。

   使用flex布局，可以轻松地实现复杂的布局效果，例如：垂直居中、等高布局、流式布局等等。同时，flex布局也很容易实现响应式设计，即根据不同屏幕大小和设备类型调整布局。

   通过设置父容器的 display 属性为 flex 或 inline-flex，可以启用Flex布局。然后可以通过设置各个子元素的 flex 属性来控制它们的弹性表现。Flex布局的容器有以下属性：flex-direction

   •  flex-wrap

   •  flex-flow

   •  justify-content

   •  align-items

   •  align-content。

   常用的Flex布局的项目有以下属性：

   •  order

   •  flex-grow

   •  flex-shrink

   •  flex-basis

   •  flex

   •  align-self

   [flex 布局的基本概念 - CSS：层叠样式表 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)

5. **回流和重绘**

   回流和重绘是前端开发中的两个重要概念。

   回流（reflow）：当Rendering Tree中部分元素的尺寸大小、布局、隐藏等属性改变时，浏览器的布局需要调整，则需要重新渲染DOM。这个过程称为回流，又称为重排。

   重绘（repaint）：当Rendering Tree中元素的属性虽然发生了改变，但没有影响其在布局上的位置时，浏览器只需要把新的样式重新绘制一遍即可，这个过程称为重绘。

   回流和重绘都会导致性能问题，因此我们应该尽量减少它们的发生。

   - 避免逐次改变样式，样式统一批量修改

   - 使DOM脱离文档流，再作批量处理

   - 缓存布局属性（需即时计算的属性）

   - position属性控制其脱离文档流

   - CSS3硬件加速，如transform、opacity、filters

   [回流（重排）与重绘 —— 什么是回流和重绘，造成的原因是什么，如何去减少？_定义重绘_Silam Lin的博客-CSDN博客](https://blog.csdn.net/qq_43263320/article/details/118361602)

6. 

## JavaScript

1. **JS函数的length**

   length 是函数对象的⼀个属性值，指该函数有多少个**必须要传⼊的参数**，即形参的个数。形参的数量不包括剩余参数个数，仅包括第⼀个具有默认值之前的参数个数。

2. **JavaScript解析URL**
   将URL字符串解析为`URL`对象，就可以轻松获取URL的各个部分和查询参数。

   ```js
   const url = "https://www.example.com/path/to/page?query=value#fragment";
   
   // 解析URL
   const parsedUrl = new URL(url);
   
   // 获取各个部分
   const protocol = parsedUrl.protocol; // "https:"
   const hostname = parsedUrl.hostname; // "www.example.com"
   const pathname = parsedUrl.pathname; // "/path/to/page"
   const search = parsedUrl.search; // "?query=value"
   const hash = parsedUrl.hash; // "#fragment"
   
   // 获取查询参数
   const queryParams = new URLSearchParams(search);
   const queryValue = queryParams.get("query"); // "value"
   ```

   正则表达式：

   ```js
   function parseUrl(url) {
     const regex = /^([^:]+):\/\/([^\/]+)(\/[^?#]*)(\?[^#]*)?(#.*)?$/;
     const match = url.match(regex);
   
     if (!match) {
       throw new Error("Invalid URL");
     }
   
     const [_, protocol, hostname, pathname, search, hash] = match;
   
     return {
       protocol,
       hostname,
       pathname,
       search: search || "",
       hash: hash || ""
     };
   }
   ```

   这个正则表达式`/^([^:]+):\/\/([^\/]+)(\/[^?#]*)(\?[^#]*)?(#.*)?$/` 解释如下：

   - `^` 表示匹配字符串的开头。
   - `([^:]+)` 匹配除了冒号以外的任意字符，一个或多个。这个部分用来匹配协议（比如`http`或`https`）。
   - `:\/\/` 匹配冒号和两个斜杠，即协议后面的部分。
   - `([^\/]+)` 匹配除了斜杠以外的任意字符，一个或多个。这个部分用来匹配主机名。
   - `(\/[^?#]*)` 匹配一个斜杠，后面跟着零个或多个非问号和非井号的字符。这个部分用来匹配路径。
   - `(\?[^#]*)?` 匹配一个问号，后面跟着零个或多个非井号的字符。这个部分用来匹配查询字符串。注意这个部分是可选的，因为URL可能没有查询字符串。
   - `(#.*)?` 匹配一个井号，后面跟着零个或多个任意字符。这个部分用来匹配哈希。注意这个部分也是可选的，因为URL可能没有哈希。
   - `$` 表示匹配字符串的结尾。

   query-string库：

   ```js
   import queryString from 'query-string';
   
   const url = "https://www.example.com/path/to/page?query=value&foo=bar#fragment";
   
   // 解析URL的查询参数
   const queryParams = queryString.parseUrl(url).query;
   
   // 将查询参数转换为对象
   const queryObject = queryString.parse(queryParams);
   
   console.log(queryObject); // { query: 'value', foo: 'bar' }
   ```

   还可以直接splice一个个切。

3. **JS正则表达式**

   JavaScript正则表达式是一种强大的字符串匹配工具，用于从文本中查找符合某种模式的字符串。下面是JavaScript正则表达式的一些常用用法：

   创建正则表达式对象

   可以使用`RegExp`对象来创建正则表达式对象：

   ```
   let regExp = new RegExp("pattern");
   ```

   也可以使用字面量形式来创建正则表达式对象：

   ```
   let regExp = /pattern/;
   ```

   其中，"pattern"是正则表达式模式。

   字符类和元字符

   在正则表达式中，一些特殊字符被称为元字符。它们有特殊的含义，比如表示任意字符、匹配数字等。

   另外一些字符被称为字符类，它们用于匹配一组指定的字符。

   例如，下列是一些常用的元字符和字符类：

   - `. (点)`：匹配除换行符以外的任意字符。
   - ^：匹配输入的开始。
   - $：匹配输入的结束
   - `\d`：匹配任意一个数字。
   - `\w`：匹配任意一个字母或数字或下划线。
   - `\s`：匹配任意一个空白字符，包括空格、制表符、换行符等。
   - `[]`：用来定义一个字符集合，匹配其中任意一个字符。
   - `[^]`：用来定义一个反向字符集合，匹配不在其中的任意一个字符。

   量词

   在正则表达式中，可以使用量词来指定一个模式出现的次数。

   例如，下列是一些常用的量词：

   - `*`：匹配前面的模式零次或多次。
   - `+`：匹配前面的模式一次或多次。
   - `?`：匹配前面的模式零次或一次。
   - `{n}`：匹配前面的模式恰好n次。
   - `{n,}`：匹配前面的模式至少n次。
   - `{n,m}`：匹配前面的模式至少n次，但不超过m次。

   匹配方法

   在JavaScript中，有两种主要的正则表达式匹配方法：`test()和exec()`。

   `test()`方法会返回一个布尔值，表示给定的字符串是否匹配某个正则表达式。例如：

   ```
   let regExp = /\d+/;
   console.log(regExp.test("123abc")); // true
   console.log(regExp.test("abc")); // false
   ```

   `exec()`方法会返回一个数组，其中包含了所有与正则表达式匹配的子串以及匹配的位置等信息。例如：

   ```
   let regExp = /(\d+)([a-z]+)/;
   let result = regExp.exec("123abc");
   console.log(result); // ["123abc", "123", "abc"]
   ```

   JavaScript中字符串的正则表达式方法有以下几种：

   `match()`：该方法通过正则表达式匹配字符串，返回一个数组，如果使用 g 标志，则包含所有匹配的子字符串。如果未使用 g 标志，则仅返回第一个完整匹配及其相关的捕获组(和`RegExp.exec()`相同。如果没有匹配到，则返回null。

   示例代码：

   ```
   const str = "hello world";
   const regex = /l+/g;
   const matches = str.match(regex);
   console.log(matches); // ['ll', 'l']
   ```

   `search()`：该方法通过正则表达式在字符串中查找匹配项。如果找到了匹配项，则返回它在字符串中的索引位置。如果没有匹配项，则返回-1。

   `replace()`：该方法通过正则表达式将匹配的子字符串替换成新的字符串。可以使用$1、$2等特殊符号引用正则表达式中的分组内容。

   `split()`：该方法通过正则表达式将字符串分割成子字符串，并将这些子字符串存储在数组中。

   这些都是JavaScript中常用的字符串正则表达式方法。

4. **JS常用的新语法**

   1. 变量声明：使用let和const关键字来声明变量，其中let声明的变量可以重新赋值，而const声明的变量是不可修改的常量。
   2. 模板字符串：使用反引号（`）来定义模板字符串，可以通过${}来插入变量或表达式，使得字符串拼接更加简洁。
   3. 箭头函数：使用箭头（=>）定义函数，可以避免this指针的问题，并且语法更加简洁。
   4. 解构赋值：可以从数组或对象中提取值并赋给变量，使得代码更加清晰易懂。
   5. 函数参数默认值：可以为函数的参数设置默认值，当未传递参数时会自动使用默认值。
   6. 扩展运算符：使用三个点（...）来表示扩展运算符，可以将数组或对象展开成单独的元素。
   7. 类和继承：使用class关键字定义类，可以方便地实现面向对象编程，并支持继承。
   8. Promise、async/await

   [ES7 到 ES12 常用新语法 - 掘金 (juejin.cn)](https://juejin.cn/post/7007393969994891301)

5. **JS基本数据类型**

   当前Javascript中有7种基本数据类型：String、Number、Boolean、Null、Undefined、Symbol(ES6)、BigInt(ES10)

   [Javascript 基本数据类型 - 掘金 (juejin.cn)](https://juejin.cn/post/7094522166246375437)

   除了上述基本数据类型外，JavaScript还有一种特殊的数据类型，称为对象（Object）。

6. **JS数据类型的判断**

   可以使用`typeof`操作符来判断数据类型，可以区别基本数据(除去null)和函数。但需要注意对于数组和其他对象以及null `typeof`返回的都是"object"，无法区分它们。

   可以使用`Array.isArray()`函数来检测数组

   或者使用`Object.prototype.toString.call(obj)`方法来检测对象。

   `instanceof`操作符：可以检测对象是否是某个构造函数的实例。

   constructor属性：每个JavaScript对象都有一个constructor属性，该属性指向用于创建该对象的构造函数。可以使用该属性来检测对象的类型。

   对象原型链判断方法： prototype 通用但很繁琐。

   [JS 判断数据类型的 8 种方式 - 掘金 (juejin.cn)](https://juejin.cn/post/7200396667505704997#heading-9)

7. 1

## Vue

1. **v-show v-if区别**

   v-show和v-if都是Vue.js中用于控制元素显示或隐藏的指令，但它们有以下几点不同：

   1. 原理：v-show只是通过更改元素的CSS样式（display属性）来控制元素的显示或隐藏；而v-if通过添加或删除DOM元素来控制元素的显示或隐藏。 v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件，v-show只是简单的基于css切换。
   2. 开销：v-show的开销较小，因为元素始终在DOM中，并且只需要修改CSS样式即可控制其显示或隐藏；而v-if的开销较大，因为每次条件判断为true时，需要重新创建元素并添加到DOM中，当条件判断为false时，则需要从DOM中删除该元素。v-if有更高的切换开销，而v-show有更高的初始渲染开销。
   3. 使用场景：通常情况下，v-show适用于需要频繁切换显示状态的元素，而v-if适用于需要根据条件动态创建或删除元素的情况。因此，如果一个元素可能会经常显示和隐藏，则使用v-show会更好；而如果一个元素只需要在特定条件下出现，而且不需要频繁切换显示状态，则使用v-if会更好。

2. **Vue的特点**

   Vue具有以下特点：

   1. 组件化：Vue组件是可重用的代码块，可以让开发人员轻松地创建、组合和维护复杂的UI界面。
   2. 响应式数据绑定：Vue提供了数据绑定机制，当数据改变时，视图会自动更新。这使得开发人员能够更轻松地管理应用程序的状态，从而提高生产力。
   3. 轻量级：Vue非常轻巧，只需要很少的依赖就可以使用。这使得Vue非常适合开发小型项目或者需要快速原型设计的项目。
   4. 易于学习：Vue的文档十分详细，学习曲线相对较低。同时，Vue也提供了很多插件和工具来帮助开发人员更轻松地实现常见的任务。

   [什么是Vue、Vue的特点、Vue的优点及性能优化、应用场景_vue框架的特点和优点_燕穗子博客的博客-CSDN博客](https://blog.csdn.net/m0_64346035/article/details/124993635)

3. **MVC与MVVM模式的区别**

   **MVC思想** ：Controller负责将Model的数据用View显示出来。

   **Model** 和 **View** 并无直接关联，而是通过 **ViewModel** 来进行交互的（即双向数据绑定），

   **Model** 和 **ViewModel**之间有着**双向数据绑定的联系**。
    View的变化可以引起Model的变化，Model的变化也可以引起View变化（类似于浅拷贝）。`ViewModel`是`View`和`Model`层的桥梁，数据会绑定到`viewModel`层并自动将数据渲染到页面中，视图变化的时候会通知`viewModel`层更新数据。

   [MVC与MVVM模式的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7110885291946147876)

4. **Vue响应式原理**

   在Vue2中，Vue.js使用了`Object.defineProperty`方法来实现数据劫持。当一个对象被设置为响应式时，Vue会通过`Object.defineProperty()`方法将该对象的所有属性转换为getter/setter，并且在getter/setter中收集依赖和触发更新。当访问或修改对象中的属性时，就会触发相应的getter/setter，并且通知相关的Watcher进行视图更新。无法检测到对象属性的添加和删除 。

   在Vue3中，Vue.js采用了Proxy来实现数据劫持。与`Object.defineProperty()`不同的是，Proxy可以直接监听整个对象，而不需要对对象的每个属性都设置getter/setter。当访问或修改对象中的属性时，就会触发Proxy的get/set方法，并且通知相关的Watcher进行视图更新。

   [你真的了解vue2.0 和 vue3.0 响应式原理区别吗？ - 掘金 (juejin.cn)](https://juejin.cn/post/6982001553540382733)

5. **Vue虚拟DOM**

   Vue的虚拟DOM是一种轻量级的JavaScript对象，用于描述视图的界面结构。在Vue中，每个组件都有一个render函数，每个render函数都会返回一个虚拟DOM树，这也就意味着每个组件都对应一棵虚拟DOM树。当数据发生变化时，Vue会比较新旧两棵虚拟DOM树的差异，然后将差异更新到真实的DOM上，从而实现高效的渲染

   [vue虚拟DOM详解_Goodbye_yesterday的博客-CSDN博客](https://blog.csdn.net/Goodbye_/article/details/116353745)

6. **Vue diff算法**

   当数据发生变化时，会通过Diff算法对比新旧虚拟DOM，找出变化的部分进行重新渲染。其Diff算法主要分为两个阶段：

   1. 生成新旧节点的key-index映射表

      在这个阶段，Vue会遍历新旧节点数组，将它们的key和index建立起映射关系，在记录下来。由于key属性的唯一性，这样可以更快速、准确地匹配到新旧节点的对应关系。

   2. 遍历新旧节点数组，依次进行比较与更新
      1. 比较只会在同层级进行, 不会跨层级比较
      2. 在diff比较的过程中，循环从两边向中间比较

   在这个阶段，Vue会遍历新旧节点数组，依次比较它们是否相同。如果不同，就会根据key-index映射表找到对应的旧节点，再判断是否可以复用，如果可复用，则将旧节点移动至对应位置，并更新对应的数据；如果不可复用，则创建新节点并插入至对应位置。

   [vue中的diff算法_vue diff算法_star@星空的博客-CSDN博客](https://blog.csdn.net/weixin_43638968/article/details/112686317)

7. **Vue生命周期**

   Vue 3中的组件生命周期函数：

   1. `beforeCreate`：在实例被创建之前调用。此时，实例的数据、事件等都未被初始化。
   2. `created`：在实例被创建之后调用。此时，实例的数据已经被初始化，但 DOM 仍未被渲染。
   3. `beforeMount`：在实例挂载到DOM之前调用。此时，模板已经编译完成，但虚拟DOM还未被创建。
   4. `mounted`：在实例挂载到DOM之后调用。此时，虚拟DOM和真实DOM都已经被创建和渲染，可以对DOM进行操作。
   5. `beforeUpdate`：在响应式数据更新之前调用。此时，虚拟DOM已经被重建，但尚未与真实DOM同步。
   6. `updated`：在响应式数据更新之后调用。此时，虚拟DOM和真实DOM已经同步完成，可以对新的DOM进行操作。
   7. `beforeUnmount`：在实例销毁之前调用。此时，实例仍然可以被使用。
   8. `unmounted`：在实例销毁之后调用。此时，实例已经被彻底销毁，无法再被使用。
   9. `errorCaptured`: 在捕获一个来自子孙组件的异常时被调用。

   值得注意的是，Vue 3 中去除了 `destroyed` 生命周期函数，取而代之的是 `beforeUnmount` 和 `unmounted`。这两个生命周期函数的作用和 Vue 2 中的 `beforeDestroy` 和 `destroyed` 一样。

   除了这些生命周期函数之外，Vue 3 还提供了其他几个可选的生命周期函数：

   1. `activated`：在 keep-alive 组件激活时调用。
   2. `deactivated`：在 keep-alive 组件停用时调用。

8. **vue3生命周期函数的使用场景**

   1. `beforeCreate` 和 `created`：这两个生命周期函数主要用于在组件创建时执行一些初始化操作。比如，可以在 created 函数中获取后端接口数据并将其赋值给组件内部的 data 变量。
   2. `beforeMount` 和 `mounted`：这两个生命周期函数主要用于在组件被挂载到 DOM 前后执行一些操作。比如，可以在 mounted 函数中使用 $refs 获取组件内部的子元素，或者使用第三方库对 DOM 进行操作。
   3. `beforeUpdate` 和 `updated`：这两个生命周期函数主要用于在组件更新时执行一些操作。比如，在 updated 函数中使用 $watch 等方法监听数据变化，并在数据变化时执行相应的操作。
   4. `beforeUnmount` 和 `unmounted`：这两个生命周期函数主要用于在组件销毁前后执行一些清理操作。比如，可以在 `beforeUnmount` 函数中解除事件绑定、清除定时器等操作，以避免内存泄漏。
   5. `errorCaptured`：这个生命周期函数主要用于捕获来自子孙组件的异常。在这个函数中可以对异常进行处理，比如发送错误日志到服务器。
   6. `activated` 和 `deactivated`：这两个生命周期函数主要用于在 keep-alive 组件激活和停用时执行一些操作。比如，在 activated 函数中可以重新获取数据并刷新组件状态，以保证 keep-alive 缓存的数据是最新的。

9. **Vue组件之间如何通信**

   Vue3中，组件之间的通信方式有很多种，其中包括：props、\$emit、provide/inject、\$attrs/\$listeners、事件总线、Vuex等。

   [Vue3 过10种组件通讯方式 - 掘金 (juejin.cn)](https://juejin.cn/post/7069251532339806238)

10. **Vuex**

    Vuex是一个状态管理模式和库，用于在Vue.js应用程序中管理共享状态。Vuex可以将整个应用程序的状态集中存储到一个容器中，并使用严格的规则来确保状态只能按照预期的方式进行更改。

    Vuex包含四个核心概念：

    1. State：定义了应用程序的单一状态树。它是一个JavaScript对象，其中包含了应用程序中所有组件所需的共享状态数据。
    2. Getters：从state中派生出一些状态，类似于Vue组件中的计算属性。Getters可以使用具有缓存功能的computed选项来定义。
    3. Mutations：是唯一更改状态的方法。它们接受一个当前状态作为第一个参数，以及可选的负载作为第二个参数。Mutations必须是同步函数。
    4. Actions：用于处理异步操作或批量提交mutations。Actions接收一个context参数，其中包含了与store实例相同的方法和属性。

    

11. 