## 基本常识

1. **常见的不稳定排序算法**

   在排序算法中，稳定性是指如果在待排序的数组中存在两个相等的元素，在排序后，它们**在数组中的相对位置是否发生变化**。如果相等元素的相对位置没有发生变化，那么这个排序算法就是稳定的；反之，则是不稳定的。

   1. 快速排序：快速排序是一种分治算法，通过划分将待排序数组划分为左右两个子数组，然后递归地对这两个子数组进行排序，最终得到有序数组。但是由于其涉及到元素的交换操作，因此它是不稳定的。
   2. 堆排序：堆排序是利用堆这种数据结构来实现排序的算法。堆分为大根堆和小根堆，大根堆要求每个节点的值都不大于其父节点的值，而小根堆要求每个节点的值都不小于其父节点的值。在堆排序中，我们首先将待排序数组构造成一个堆，然后将堆顶元素与堆底元素交换，并重新调整堆，最终得到有序数组。由于堆排序中涉及到元素的交换操作，因此它也是不稳定的。
   3. 希尔排序：希尔排序是一种改进版的插入排序算法，它通过在原始数据上进行多次排序，每次排序时将数据分成若干个小组，在每个小组内部进行插入排序。希尔排序的不稳定性来源于其间隔序列的选取方式。
   4. 直接选择排序法。基本思想是：第一趟从n个元素的数据序列中选出关键字最小（或最大）的元素并放到最前（或最后）位置，下一趟再从n-1个元素中选出最小（或最大）的元素并放到次前（后）位置，以此类推，经过n-1趟完成排序。涉及到元素的交换操作，因此它也是不稳定的。

   需要注意的是，并不是所有的排序算法都是不稳定的。例如，冒泡排序、插入排序和归并排序等算法都是稳定的排序算法。

2. 

## HTML与浏览器

1. **为什么 `setTimeout `不阻塞后⾯程序的运⾏？**

   因为 `setTimeout `不是由` js` 引擎线程完成的，是由定时器触发线程完成的，所以它们可以同时进⾏，那么定时器触发线程在这定时任务完成之后会通知事件触发线程往任务队列⾥添加事件。同理，也有异步` HTTP` 请求线程。

2. **常见的异步场景？**

   1. 定时器
   2. 网络请求
   3. 事件绑定
   4. Promise

3. **Event Loop 事件循环**

   记住script本身是宏任务，在这个过程中可能会创建微任务。

   先执行宏任务，再执行产生的所有微任务。（微任务在宏任务之间执行）

   - **常见的宏任务：**`script`整体代码、`setTimeout` 和 `setInterval`（`setImmediate`：`node` 的⽅法）、`requestAnimationFrame`、`I/O`、`UI rendering`

   - **常见的微任务：**`process.nextTick (Node环境中)`、`Promise callback`(例如 `promise.then`)、`MutationObserver`

   举例：主程序和 `setTimeout `都是宏任务，`promise `是微任务，第⼀个宏任务（主程序）执⾏完，执⾏全部的微任务（`promise`），再执⾏下⼀个宏任务
   （`setTimeout`）。

   还需要注意：await是等待，需要把**当前队列中的所有微任务执⾏完**，再执⾏await下面的内容。而await下⾯的内容执⾏完，才⼜执⾏宏任务。

   简述Event Loop 事件循环：Event Loop 事件循环是指浏览器或Node的一种解决JavaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。JavaScript是单线程的，即一次只能执行一个任务，而Event Loop就是用来协调任务执行的机制。当我们执行一个异步操作时，会将其放到Web API中，等合适的时候放入任务队列。当事件循环开始时，会先执行当前调用栈中的所有同步任务。在任务执行期间，如果产生了宏任务，会添加到宏任务队列。如果产生了微任务，那么这些微任务会被添加到微任务队列中，并在当前宏任务执行完毕后立即执行。如果在微任务执行期间产生了新的微任务，则这些新的微任务也会被添加到微任务队列中。只有当微任务队列为空时，才会去执行下一个宏任务。这个过程会一直持续下去，直到所有的任务都被处理完毕。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

   [JavaScript之彻底理解EventLoop - 掘金 (juejin.cn)](https://juejin.cn/post/7020328988715270157)

   [JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2014/10/event-loop.html)

4. **node.js 事件循环**

   ```
      ┌───────────────────────────┐
   ┌─>│           timers          │       # 执⾏ setTimeout 和 setInterval 的回调
   │  └─────────────┬─────────────┘		
   │  ┌─────────────┴─────────────┐
   │  │     pending callbacks     │		# 执行推迟到下一个循环迭代的I/O回调。
   │  └─────────────┬─────────────┘
   │  ┌─────────────┴─────────────┐
   │  │       idle, prepare       │		# 内部调用 (可忽略)
   │  └─────────────┬─────────────┘      ┌───────────────┐
   │  ┌─────────────┴─────────────┐      │   incoming:   │
   │  │           poll            │<─────┤  connections, │		# 执行与I/O相关的回调（除了关闭回调、定时器回调和setImmediate()之外，几乎所有回调都执行）
   │  └─────────────┬─────────────┘      │   data, etc.  │
   │  ┌─────────────┴─────────────┐      └───────────────┘
   │  │           check           │		# 执⾏ setImmediate 回调
   │  └─────────────┬─────────────┘
   │  ┌─────────────┴─────────────┐
   └──┤      close callbacks      │		# 一些关闭回调，例如socket.on（“关闭”，…）。
      └───────────────────────────┘
   ```

5. **同源策略**

   同源： 协议、域名、端口均相等。非同源会发生跨域。

   由于同源策略的限制，跨域请求发送到后端，后端返回数据时会**被浏览器**的跨域报错拦截。

   **解决跨域：**

   `JSONP`：利用`script，link，img，href，src`不受跨域问题限制。通过标签指向⼀个需要访问的地址并提供⼀个回调函数来接收数据。只⽀持GET⽅法且不安全，且需要前后端配合。

   `postMessage`：这种⽅式通常⽤于获取嵌⼊页⾯中的第三⽅页⾯数据。需要使用到iframe标签（依赖于iframe标签实现A——>B，B——>A的数据交互），A域与B域通过`iframe`标签构建成父子级关系。通过window 提供的 `postMessage` 方法和 `message` 事件实现跨域通信。

   `CORS`：服务端设置 `Access-Control-Allow-Origin `就可以开启 `CORS`。是基于`HTTP1.1`的⼀种跨域解决⽅案。

   代理：一般用于⽣产环境不发⽣跨域，但开发环境发⽣跨域。只需要在开发环境使⽤代理解决跨域。

   `nginx` 代理：反向代理：帮服务器拿到数据，然后选择合适的服务器。和CORS原理同，需要配置请求响应头`Access-Control-Allow-Origin`等字段。把http请求转发到另⼀个或者⼀些服务器上。通过把本地⼀个`url`前缀映射到要跨域访问的web服务器上，就可以实现跨域访问。

   `WebSocket` 协议(与`HTTP`同级)：跨域检测工作就交给了服务端。`WebSocket`请求头信息中有`origin`字段，表⽰请求源⾃哪个域，服务器可以根据这个字段判断是否允许本次通信。

   `document.domain + iframe`：两个域名必须属于同一个一级域名!而且所用的协议，端口都要一致，否则无法利用`document.domain`进行跨域。

   `location.hash + iframe`：A和C同源，A和B非同源，通过C页⾯实现A和B通信。利用`location.hash`传值, 监控hash的变化，执行相应的操作。

   `window.name(共享变量) + iframe`：window.name属性有这样的特点: 当前页设置的值, 在页面重新加载(非同域也可以)后, 值依然不变。给`iframe`赋值跨域的链接，加载完后触发`load`事件，此时`iframe`已经拿到数据放在`window.name`里，因为浏览器同源策略没法直接拿`iframe`的name值，所以将iframe的地址改成同域名下的一个网页，再用`contentWindow`方法获取iframe的name值拿数据，而这个那么是同一个name，所以就实现了跨域。

6. **Content-Type 常见的值**

   - `text/html `： HTML格式
   - `text/plain` ：纯文本格式   
   - `multipart/form-data`   （上传文件的时候，使用的媒体格式类型）
   - `application/x-www-form-urlencoded ` （表单默认的提交数据的格式）
   - `application/json`  ： JSON数据格式

7. **在浏览器输入 URL 回车之后发生了什么？**

   1. URL解析：判断是搜索内容还是请求URL。

   2. 查找缓存：检查本地是否缓存了该请求资源，`expires`和`cache-control`判断是否命中强缓存，`If-Modified-Since(last_modified)`和`If-None-Match(ETag)`判断是否命中协商缓存。

   3. 域名解析：浏览器缓存>系统缓存>hosts⽂件>本地DNS服务器>根域名服务器>顶级域名服务器>权限域名服务器

   4. TCP三次握⼿

      1. 客户端：标志位SYN=1，序号Seq=x，进⼊SYN-SENT状态
      2. 服务器：标志位SYN=1，ACK=1，序号seq=y，确认号ack=x + 1，进入SYN-RCVD状态
      3. 客户端：标志位ACK=1，序号seq=x+1，确认号ack=y+1，进⼊ESTABLISHED状态。服务器端收到确认后，也进⼊ESTABLISHED状态，由此成功建⽴了TCP连接

      三次握手是为了避免服务器等待造成资源浪费。

   5. 发送HTTP请求

   6. 服务器处理请求并返回报⽂

   7. 客户端处理响应，⾸先检查服务器响应报⽂的状态码

   8. TCP四次挥⼿ 关闭TCP连接

      1. 客户端：主动断开连接，标志位FIN=1，序号位seq=u，并停⽌发送数据，进入FIN_WAIT_1状态
      2. 服务器：若还需传输数据，⽆法⽴即关闭连接，先返回⼀个标志位ACK=1，序号seq=v，确认号ack=u+1的数据包，进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态
      3. 服务器：服务器准备好断开连接后，标志位FIN=1，标志位ACK=1，序号seq=w，确认号ack=u+1，进入LAST_ACK状态。
      4. 客户端：客户端收到后返回⼀个标志位ACK=1，序号seq=u+1，确认号ack=w+1的数据包，进入TIME_WAIT状态，需要等待2MSL(`Maximum Segment LifeTime`报文最大生成时间)进入CLOSE状态。服务器收到数据包后直接进入CLOSE状态。

   9. 浏览器解析渲染页⾯

      1. 解析HTML，构建DOM树
      2. 解析CSS，⽣成CSS规则树
      3. 合并DOM树和CSS规则，⽣成render树
      4. 布局render树（Layout/reflow），负责各元素尺⼨、位置的计算
      5. 绘制render树（paint），绘制页⾯像素信息
      6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显⽰在屏幕上

8.  **前端路由**

   搭配SPA单页面应用框架。可以不向后台发送请求而直接通过前端技术实现多个页面的效果。

   前端路由主要有以下两种实现方案：

   - `Hash`：基于 `location.hash` 来实现的，`hash` 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制`hash` 的切换。可以使用 `hashchange` 事件来监听 `hash` 的变化。可以通过你`a`标签或者`js`修改触发`hashchange` 事件。兼容性好，但路径在#后⾯，不美观。
   - `History`：`history.pushState()` 和 `history.repalceState()`。这两个 `API`可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。我们可以使用 `popstate` 事件来监听 `url` 的变化，但通过浏览器前进后退改变 URL 时会触发 `popstate` 事件, 而`pushState()/replaceState()` 不会触发 `popstate` 事件，这时我们需要手动触发页面渲染；简洁美观但需要服务端对路由进行相应配合设置。

9. **前端缓存**

   HTTP缓存：

   - 强缓存：当命中强缓存的时候，客户端不会再请求服务器，直接从缓存中读取内容，并返回HTTP状态码200。在响应头由 `Expires、Cache-Control 和 Pragma`控制，优先级`Pragma > Cache-Control > Expires`。
   - 协商缓存：向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源。响应头中有两个字段标记规则`Last-Modified / If-Modified-Since`、`Etag / If-None-Match`（优先级更高）。

   Memory Cache：内存中的缓存，主要包含的是当前中页⾯中已经抓取到的资源,例如页⾯上已经下载的样式、脚本、图⽚等。会随着进程的释放⽽释放。 ⼀旦我们关闭Tab页⾯，内存中
   的缓存也就被释放了。

   Disk Cache：硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，⽐之 Memory Cache 胜在容量和存储时效性上。

   Push Cache：（推送缓存）是 HTTP/2 中的内容，它只在会话（Session）中存在，⼀旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右。

10. **Cookie**

    重要字段：`name = value` 如果⽤于保存⽤户登录态，赋值 cookie 的名称和值; `expires=datecookie`有效期; `path=path`将服务器上的⽂件⽬录作为cookie的使⽤对象; `domain=域名` cookie适⽤对象的域名, cookie的作用域是domain本⾝以及domain下的所有⼦域名; `HttpOnly`不能通过 JS 访问 Cookie，减少XSS 攻击; `secure`只能在协议为 HTTPS 的请求中携带cookie; `same-site`规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击。

    - 影响性能，最⼤为4kb
    - ⼀个浏览器对于⼀个⽹站只能存不超过20个Cookie，⽽浏览器⼀般只允许存放300个Cookie
    - 移动端对Cookie⽀持不友好
    - ⼀般情况下存储的是纯⽂本，对象需要序列化之后才可以存储，解析需要反序列化

11. **Webstorage**

    `localStorage`：

    - ⽣命周期：持久化的本地存储，除⾮⼿动删除数据，否则数据是永远不会过期的
    - 存储的信息在同⼀域中共享
    - ⼤⼩：5M+，和浏览器⼚商有关
    - 本质上是对字符串的读取，若存储内容过多会消耗内存空间，导致页⾯卡顿
    - 受同源策略限制

    `sessionStorage`：和`localStorage`唯⼀不同就是⽣命周期，⼀旦页⾯关闭，`sessionStorage`将会删除数据。

    `IndexedDB`：扩展的前端存储⽅式，是运⾏在浏览器中的⾮关系型数据库，理论上容量⽆上限。可以理解为`localStorage`的加强版。

12. **权限验证**

    `Cookie`

    `Cookie-session`：`cookie`⼤⼩有限制，所以后端返回`sessionId`，客户端将`sessionid`存在`cookie`中。服务器根据`sessionId`去缓存系统获取⽤户信息和认证。

    `SSO`：`Single Sign On`单点登录，CAS（中央认证服务）原理。

    `Json Web Token`：最简单的 token 组成 :uid( ⽤户唯⼀的⾝份标识 ) 、 time( 当前时间的时间戳 ) 、 sign( 签名，由 token 的前⼏位 + 哈希算法压缩成⼀定长的⼗六进制字符串，防⽌恶意三⽅拼接 token 请求。JWT由header（头部）、payload（负载）、signature（签名）这三个部分组成，中间⽤`.`来分隔开：`Header.Payload.Signature`。 JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。session 和 token 的对⽐就是「⽤不⽤cookie」和「后端存不存」的对⽐。

13. **性能优化**

    1. **从用户角度**，优化能够让页面加载得更快、对用户的操作响应更快，给用户提供更为友好的体验。
    2. **从服务商角度**，优化能够减少页面请求数、或者减小请求所占带宽，节省资源。

    [常见的web前端性能优化方法总结「建议收藏」 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2097537)

    渲染优化

    - 懒执⾏：将某些逻辑延迟到使⽤时再计算。该技术可以⽤于⾸屏优化，对于某些耗时逻辑并不需要在⾸屏就使⽤的，就可以使⽤懒执⾏。懒执⾏需要唤醒，⼀般可以通过定时器或者事件的调⽤来唤醒。
    - 懒加载：将不关键的资源延后加载——尽量只加载⽤户正 浏览 或即将会 浏览的图⽚。对于图⽚来说，先设置图⽚标签的` src` 属性为⼀张占位图，真实的图⽚资源放⼊⾃定义属性`data-src` 中，当进⼊⾃定义区域时，就将⾃定义属性替换为 `src `属性，这样就会下载图⽚资源。可以搭配`offsetTop、scrollTop`、`Element.getBoundingClientRect()`、`IntersectionObserver API`检测元素是否出现在可视窗。

    节流防抖:

    - 防抖：单位时间内多次触发，只执⾏最后的那⼀次，原理：延迟执⾏，期间但凡有新的触发就重置定时器
    - 节流：单位时间只触发⼀次，原理：上锁，只有满⾜⼀定间隔时间才能再次执⾏

    CDN：内容分发⽹络，它是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。静态资源使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个CDN 域名。与传统访问方式不同，CDN网络则是在用户和服务器之间增加缓存层，将用户的访问请求引导到最优的缓存节点而不是服务器源站点，从而加速访问速度。

    如何渲染几万条数据并不卡住界面：想让几万条数据渲染并且不卡住页面，那么你就需要像大文件上传一样，做到分块渲染，大批量同步渲染，浏览器不卡死才怪呢。
    我们需要尽可能地避免重排（回流）的次数，此时可以考虑使用`createDocumentFragment()`，结合`window.requestAnimationFrame()`。[如何渲染几万条数据并不卡住界面 - 掘金 (juejin.cn)](https://juejin.cn/post/6953501066344267813)

14. **前端安全**

    **XSS跨站脚本攻击：Cross Site Scripting**

    从攻击代码的工作方式可以分为三个类型：

    - 持久型跨站：最直接的危害类型，跨站代码存储在服务器（数据库）。经过后端，经过数据库。
    - 非持久型跨站：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。经过后端，不经过数据库。
    - DOM跨站（DOM XSS）：DOM（document object model文档对象模型），客户端脚本处理逻辑导致的安全问题。

    防范：对输⼊转码过滤、利⽤CSP（浏览器内容安全策略，核⼼就是服务器决定浏览器加载哪些资源）、`HttpOnly`（阻⽌JS对cookie的访问）

    [这一次，彻底理解XSS攻击 - 掘金 (juejin.cn)](https://juejin.cn/post/6912030758404259854)

    **CSRF-跨站伪造请求（钓鱼）：Cross-Site Request Forgery**

    攻击者诱导受害者进⼊第三⽅⽹站，在第三⽅⽹站中，向被攻击⽹站发送跨站请求。利⽤受害者在被攻击⽹站已经获取的注册凭证（⽐如cookie） ，绕过后台的⽤户验证，因此可以冒充⽤户对被攻击的⽹站执⾏某项操作。本质：利⽤ cookie 会在同源请求中携带发送给服务器的特点，以此冒充⽤户。

    防范：`SameSite`（禁⽌第三⽅请求携带Cookie）、验证来源站点（请求头中的`origin`和`referer`信息）、`token`、安全框架(如Spring Security)

    [对于跨站伪造请求（CSRF）的理解和总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37293032)

    **DDoS全称Distributed Denial of Service**

    意思为“分布式拒绝服务”，即利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。

    **HTTPS中间⼈攻击**

    客户端和服务器之间的桥梁、双向获取并且篡改信息。攻击者通过与客户端和客户端的⽬标服务器同时建⽴连接，作为客户端和服务器的桥梁，处理双⽅的数据，整个会话期间的内容⼏乎完全被攻击者控制。攻击者可以拦截双⽅的会话并且插⼊新的数据内容

    [你连 HTTPS 原理都不懂,还讲“中间人攻击”? - 掘金 (juejin.cn)](https://juejin.cn/post/6844904065227292685)
    
15. **HTTP状态码**

    HTTP状态码是Web服务器向客户端返回的三位数的代码，它表示HTTP请求的处理情况。共分为5类，具体介绍如下：

    1xx（信息性状态码）：表示服务器已接收到请求，正在处理中。 

    2xx（成功状态码）：表示服务器已成功接收、理解并处理了请求。

     3xx（重定向状态码）：表示客户端需要进行进一步的操作才能完成请求。

     4xx（客户端错误状态码）：表示客户端提交的请求有误或者不能被服务器所理解。

     5xx（服务器错误状态码）：表示服务器在处理请求时出现了错误。

    常见的状态码包括：

    - 200 OK: 请求成功
    - 301 Moved Permanently: 资源被永久转移
    - 302 Found: 资源被临时转移
    - 307 Temporary Redirect 请求的资源临时从不同的URI 响应请求。
    - 400 Bad Request: 请求错误
    - 401 Unauthorized: 未授权
    - 404 Not Found: 资源未找到
    - 500 Internal Server Error: 服务器内部错误
    - 503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。

    [HTTP状态码最全详解_http状态码设计规范_IT阿剂的博客-CSDN博客](https://blog.csdn.net/qq_42402086/article/details/107491536)

16. 

## CSS

1. **CSS属性值百分比**

   - `width/height`: 大部分情况下，参照包含块（父元素）的内容区，width参照width，height参照height。需要注意的是当一个元素的高度使用百分比值，如果其父元素没有明确的高度定义（也就是说，取决于内容高度），且这个元素不是绝对定位，则该百分比值等同于auto。
   - `margin/padding`：对于margin和padding，其**任意方向**的百分比值，参照都是包含块的**宽度**。需要注意的是margin负值：margin-top和margin-left 负值，元素向上、向左移；margin-right 负值，右侧元素左移，自身不受影响；margin-bottom 负值，下方元素上移，自身不受影响。
   - `border-radius`：百分比值，参照物是这个**元素自身的尺寸**。需要注意的一点是border-radius的简写，和padding、margin类似，三个值时，是第二个和第四个值相同。二个值时1，3和2，4相同。

2. **display，opacity，visibility三者之间的区别**

   `display`，`opacity` 和 `visibility` 是用于控制网页元素**可见性**的三个不同的 CSS 属性。

   `display` 属性决定了一个元素在网页上的显示方式。它可以取值为 `block`、`inline`、`none` 等等。当设置为 `display:none` 时，该元素将**从文档中正常流中移除**，并且不会占据任何页面空间。**无法进行DOM事件监听**。会引起**重排、重绘**，性能较差。**不会被子元素继承**，因为子元素也不被渲染。`transtion`过渡不支持display。

   `opacity` 属性用于调整元素的透明度级别。它可以取值介于 0（完全透明）和 1（完全不透明）之间。这个属性不影响页面布局。**可以进行DOM事件监听**。**提升为合成层，不会引发重绘**，性能较高。会被子元素继承，**子元素不能通过设置opacity:1;来取消隐藏**。opacity可以通过`transtion`延时显示与隐藏。visibility的`transtion`会立即显示，隐藏时会延时。

   `visibility` 属性控制一个元素是可见还是隐藏。它可以取值为 `visible`、`hidden`、`collapse`。当一个元素被设置为 `visibility:hidden` 时，它仍然在页面布局中占有空间，但是不可见。**无法进行DOM事件监听。**动态改变此属性时会引起重绘，性能较高。会被子元素继承，子元素通过设置`visibility:visible`来显示自身，使子元素取消自身隐藏。

   总之，`display` 属性影响元素的布局和可见性，`opacity` 属性影响元素的透明度水平，而 `visibility` 属性控制元素是可见还是隐藏并且仍保留其在布局中的位置。

   [display，opacity，visibility三者之间的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/6856383657209724941)

3. **`css`选择器优先级**

3. 

## JavaScript

1. **JS函数的length**

   length 是函数对象的⼀个属性值，指该函数有多少个**必须要传⼊的参数**，即形参的个数。形参的数量不包括剩余参数个数，仅包括第⼀个具有默认值之前的参数个数。

2. **JavaScript解析URL**
   将URL字符串解析为`URL`对象，就可以轻松获取URL的各个部分和查询参数。

   ```js
   const url = "https://www.example.com/path/to/page?query=value#fragment";
   
   // 解析URL
   const parsedUrl = new URL(url);
   
   // 获取各个部分
   const protocol = parsedUrl.protocol; // "https:"
   const hostname = parsedUrl.hostname; // "www.example.com"
   const pathname = parsedUrl.pathname; // "/path/to/page"
   const search = parsedUrl.search; // "?query=value"
   const hash = parsedUrl.hash; // "#fragment"
   
   // 获取查询参数
   const queryParams = new URLSearchParams(search);
   const queryValue = queryParams.get("query"); // "value"
   ```

   正则表达式：

   ```js
   function parseUrl(url) {
     const regex = /^([^:]+):\/\/([^\/]+)(\/[^?#]*)(\?[^#]*)?(#.*)?$/;
     const match = url.match(regex);
   
     if (!match) {
       throw new Error("Invalid URL");
     }
   
     const [_, protocol, hostname, pathname, search, hash] = match;
   
     return {
       protocol,
       hostname,
       pathname,
       search: search || "",
       hash: hash || ""
     };
   }
   ```

   这个正则表达式`/^([^:]+):\/\/([^\/]+)(\/[^?#]*)(\?[^#]*)?(#.*)?$/` 解释如下：

   - `^` 表示匹配字符串的开头。
   - `([^:]+)` 匹配除了冒号以外的任意字符，一个或多个。这个部分用来匹配协议（比如`http`或`https`）。
   - `:\/\/` 匹配冒号和两个斜杠，即协议后面的部分。
   - `([^\/]+)` 匹配除了斜杠以外的任意字符，一个或多个。这个部分用来匹配主机名。
   - `(\/[^?#]*)` 匹配一个斜杠，后面跟着零个或多个非问号和非井号的字符。这个部分用来匹配路径。
   - `(\?[^#]*)?` 匹配一个问号，后面跟着零个或多个非井号的字符。这个部分用来匹配查询字符串。注意这个部分是可选的，因为URL可能没有查询字符串。
   - `(#.*)?` 匹配一个井号，后面跟着零个或多个任意字符。这个部分用来匹配哈希。注意这个部分也是可选的，因为URL可能没有哈希。
   - `$` 表示匹配字符串的结尾。

   query-string库：

   ```js
   import queryString from 'query-string';
   
   const url = "https://www.example.com/path/to/page?query=value&foo=bar#fragment";
   
   // 解析URL的查询参数
   const queryParams = queryString.parseUrl(url).query;
   
   // 将查询参数转换为对象
   const queryObject = queryString.parse(queryParams);
   
   console.log(queryObject); // { query: 'value', foo: 'bar' }
   ```

   还可以直接splice一个个切。

3. **JS正则表达式**

   JavaScript正则表达式是一种强大的字符串匹配工具，用于从文本中查找符合某种模式的字符串。下面是JavaScript正则表达式的一些常用用法：

   创建正则表达式对象

   可以使用`RegExp`对象来创建正则表达式对象：

   ```
   let regExp = new RegExp("pattern");
   ```

   也可以使用字面量形式来创建正则表达式对象：

   ```
   let regExp = /pattern/;
   ```

   其中，"pattern"是正则表达式模式。

   字符类和元字符

   在正则表达式中，一些特殊字符被称为元字符。它们有特殊的含义，比如表示任意字符、匹配数字等。

   另外一些字符被称为字符类，它们用于匹配一组指定的字符。

   例如，下列是一些常用的元字符和字符类：

   - `. (点)`：匹配除换行符以外的任意字符。
   - ^：匹配输入的开始。
   - $：匹配输入的结束
   - `\d`：匹配任意一个数字。
   - `\w`：匹配任意一个字母或数字或下划线。
   - `\s`：匹配任意一个空白字符，包括空格、制表符、换行符等。
   - `[]`：用来定义一个字符集合，匹配其中任意一个字符。
   - `[^]`：用来定义一个反向字符集合，匹配不在其中的任意一个字符。

   量词

   在正则表达式中，可以使用量词来指定一个模式出现的次数。

   例如，下列是一些常用的量词：

   - `*`：匹配前面的模式零次或多次。
   - `+`：匹配前面的模式一次或多次。
   - `?`：匹配前面的模式零次或一次。
   - `{n}`：匹配前面的模式恰好n次。
   - `{n,}`：匹配前面的模式至少n次。
   - `{n,m}`：匹配前面的模式至少n次，但不超过m次。

   匹配方法

   在JavaScript中，有两种主要的正则表达式匹配方法：`test()和exec()`。

   `test()`方法会返回一个布尔值，表示给定的字符串是否匹配某个正则表达式。例如：

   ```
   let regExp = /\d+/;
   console.log(regExp.test("123abc")); // true
   console.log(regExp.test("abc")); // false
   ```

   `exec()`方法会返回一个数组，其中包含了所有与正则表达式匹配的子串以及匹配的位置等信息。例如：

   ```
   let regExp = /(\d+)([a-z]+)/;
   let result = regExp.exec("123abc");
   console.log(result); // ["123abc", "123", "abc"]
   ```

   JavaScript中字符串的正则表达式方法有以下几种：

   `match()`：该方法通过正则表达式匹配字符串，返回一个数组，如果使用 g 标志，则包含所有匹配的子字符串。如果未使用 g 标志，则仅返回第一个完整匹配及其相关的捕获组(和`RegExp.exec()`相同。如果没有匹配到，则返回null。

   示例代码：

   ```
   const str = "hello world";
   const regex = /l+/g;
   const matches = str.match(regex);
   console.log(matches); // ['ll', 'l']
   ```

   `search()`：该方法通过正则表达式在字符串中查找匹配项。如果找到了匹配项，则返回它在字符串中的索引位置。如果没有匹配项，则返回-1。

   `replace()`：该方法通过正则表达式将匹配的子字符串替换成新的字符串。可以使用$1、$2等特殊符号引用正则表达式中的分组内容。

   `split()`：该方法通过正则表达式将字符串分割成子字符串，并将这些子字符串存储在数组中。

   这些都是JavaScript中常用的字符串正则表达式方法。

4. 